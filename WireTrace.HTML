<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VodaTrace - Network Analysis Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box; /* FAAAAAAAAAAH */
        }

        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #14191f;
            --bg-card: #1a1f2e;
            --bg-card-dark: #0d1117;
            --text-primary: #e6edf3;
            --text-secondary: #7d8590;
            --text-muted: #484f58;
            --crimson: #dc2857;
            --cyan: #00d4ff;
            --green: #3fb950;
            --border: #30363d;
            --hover: rgba(220, 40, 87, 0.1);
            --code-bg: #161b22;
            
            /* Protocol colors */
            --proto-pppoe: #ec4899;
            --proto-ipv6: #8b5cf6;
            --proto-arp: #10b981;
            --proto-tcp: #06b6d4;
            --proto-udp: #84cc16;
            --proto-dns: #a855f7;
            --proto-dhcp: #f59e0b;
            --proto-http: #f97316;
            --proto-https: #8b5cf6;
            --proto-icmp: #ef4444;
            --proto-ethernet: #94a3b8;
            --proto-sll: #64748b;
            --proto-vlan: #c084fc;
            --proto-ipv4: #38bdf8;
            
            /* Status colors */
            --status-error: #991b1b;
            --status-warning: #92400e;
            --status-ok: #065f46;
        }

        body {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header with gradient border */
        .header {
            position: relative;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 40px 30px;
            text-align: center;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 12px;
            padding: 2px;
            background: linear-gradient(90deg, var(--crimson), var(--cyan), var(--crimson));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            animation: borderFlow 4s linear infinite;
            background-size: 200% 100%;
        }

        @keyframes borderFlow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        /* Scanline effect */
        .header::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(
                180deg,
                transparent 0%,
                rgba(0, 212, 255, 0.03) 50%,
                transparent 100%
            );
            animation: scan 8s linear infinite;
            pointer-events: none;
        }

        @keyframes scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(200%); }
        }

        .header-content {
            position: relative;
            z-index: 1;
        }

        h1 {
            font-size: 48px;
            font-weight: 700;
            letter-spacing: -0.02em;
            margin-bottom: 8px;
        }

        .wire { color: var(--crimson); }
        .trace { color: var(--cyan); }

        .subtitle {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 6px;
        }

        .attribution {
            color: #475569;
            font-size: 12px;
            margin-bottom: 16px;
        }

        .reference-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--cyan);
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s;
            cursor: pointer;
        }

        .reference-btn:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: var(--cyan);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        /* Mode selector */
        .mode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .mode-btn {
            padding: 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Space Grotesk', sans-serif;
        }

        .mode-btn:hover {
            border-color: var(--crimson);
            background: var(--hover);
        }

        /* Event log hover in GREEN */
        .mode-btn.event-mode:hover {
            border-color: var(--green);
            background: rgba(63, 185, 80, 0.1);
        }

        .mode-btn.active {
            border-color: var(--crimson);
            background: rgba(220, 40, 87, 0.15);
            box-shadow: 0 0 20px rgba(220, 40, 87, 0.3);
        }

        .mode-btn.event-mode.active {
            border-color: var(--green);
            background: rgba(63, 185, 80, 0.15);
            box-shadow: 0 0 20px rgba(63, 185, 80, 0.3);
        }

        /* Drop zone */
        .drop-zone {
            border: 3px dashed var(--border);
            border-radius: 12px;
            padding: 60px 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: var(--bg-secondary);
            margin-bottom: 20px;
        }

        .drop-zone:hover, .drop-zone.drag-over {
            border-color: var(--crimson);
            background: var(--hover);
        }

        .drop-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .drop-text {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .drop-hint {
            color: var(--text-secondary);
            font-size: 13px;
        }

        /* Progress bar */
        .progress-container {
            margin-top: 15px;
            display: none;
        }

        .progress-container.show {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 3px;
            background: var(--border);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--crimson), var(--cyan));
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            margin-top: 8px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Viewer container */
        .viewer {
            display: none;
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .viewer.show {
            display: block;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px 20px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            align-items: center;
        }

        .toolbar input[type="text"] {
            flex: 1;
            min-width: 250px;
            padding: 10px 15px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        .toolbar input:focus {
            outline: none;
            border-color: var(--crimson);
        }

        .toolbar select {
            padding: 10px 15px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            cursor: pointer;
            min-width: 150px;
        }

        .toolbar button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
            font-family: 'Space Grotesk', sans-serif;
        }

        .btn-apply {
            background: var(--crimson);
            color: white;
        }

        .btn-apply:hover {
            background: #be1e3e;
        }

        .btn-clear {
            background: var(--border);
            color: var(--text-secondary);
        }

        .btn-clear:hover {
            background: #3d4758;
        }

        .btn-jump-findings {
            background: rgba(0, 212, 255, 0.15);
            color: var(--cyan);
            border: 1px solid rgba(0, 212, 255, 0.35);
        }

        .btn-jump-findings:hover {
            background: rgba(0, 212, 255, 0.25);
        }

        .time-controls {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-left: auto;
        }

        .time-label {
            color: var(--text-secondary);
            font-size: 12px;
            margin-right: 5px;
        }

        .time-btn {
            padding: 8px 14px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .time-btn.active {
            background: var(--crimson);
            color: white;
            border-color: var(--crimson);
        }

        .packet-count {
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
        }

        /* Split layout */
        .split-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            height: calc(100vh - 420px);
            min-height: 500px;
        }

        /* Packet table */
        .packet-list {
            overflow: auto;
            background: var(--bg-primary);
            border-right: 1px solid var(--border);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        thead {
            position: sticky;
            top: 0;
            background: var(--bg-card);
            z-index: 10;
        }

        th {
            padding: 8px 10px;
            text-align: left;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 0.05em;
            border-bottom: 2px solid var(--crimson);
        }

        tbody tr {
            border-bottom: 1px solid rgba(45, 55, 72, 0.5);
            cursor: pointer;
            transition: background 0.15s;
            line-height: 1.3;
        }

        tbody tr:hover {
            background: var(--bg-card);
        }

        tbody tr.selected {
            background: rgba(220, 40, 87, 0.15);
            border-left: 3px solid var(--crimson);
        }

        /* Color-coded rows for packets with issues */
        tbody tr.packet-error {
            background: rgba(153, 27, 27, 0.15);
        }

        tbody tr.packet-warning {
            background: rgba(146, 64, 14, 0.1);
        }

        tbody tr.packet-ok {
            background: transparent;
        }

        td {
            padding: 6px 8px;
            color: var(--text-primary);
        }

        .protocol {
            font-weight: 600;
            text-transform: uppercase;
        }

        .protocol-pppoe { color: var(--proto-pppoe); }
        .protocol-ipv6 { color: var(--proto-ipv6); }
        .protocol-arp { color: var(--proto-arp); }
        .protocol-tcp { color: var(--proto-tcp); }
        .protocol-udp { color: var(--proto-udp); }
        .protocol-dns { color: var(--proto-dns); }
        .protocol-dhcp { color: var(--proto-dhcp); }
        .protocol-http { color: var(--proto-http); }
        .protocol-https { color: var(--proto-https); }
        .protocol-icmp { color: var(--proto-icmp); }
        .protocol-ethernet { color: var(--proto-ethernet); }
        .protocol-sll { color: var(--proto-sll); }
        .protocol-vlan { color: var(--proto-vlan); }
        .protocol-ipv4 { color: var(--proto-ipv4); }

        .text-muted { color: var(--text-secondary); }
        .truncate {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Sidebar */
        .sidebar {
            background: var(--bg-card);
            overflow: auto;
        }

        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            background: var(--bg-secondary);
        }

        .sidebar-tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .sidebar-tab:hover {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .sidebar-tab.active {
            color: var(--crimson);
            border-bottom-color: var(--crimson);
            background: var(--bg-card);
        }


        .sidebar-content {
            display: none;
            padding: 20px;
        }

        .sidebar-content.active {
            display: block;
        }

        .detail-section {
            background: rgba(45, 55, 72, 0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .detail-section h3 {
            font-size: 14px;
            color: var(--crimson);
            margin-bottom: 12px;
            font-weight: 600;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 12px;
            border-bottom: 1px solid rgba(45, 55, 72, 0.5);
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-label {
            color: var(--text-secondary);
        }

        .detail-value {
            color: var(--text-primary);
            font-weight: 600;
            text-align: right;
        }

        .layer-section {
            margin-top: 15px;
            border-left: 2px solid var(--cyan);
            padding-left: 12px;
        }

        .layer-title {
            color: var(--cyan);
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .layer-field {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .layer-field span {
            color: var(--text-primary);
        }

        /* Stats grid */
        .stats-grid {
            display: grid;
            gap: 10px;
        }

        .stat-card {
            background: rgba(45, 55, 72, 0.3);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--crimson);
        }

        .protocol-list {
            margin-top: 10px;
        }

        .protocol-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 12px;
        }

        .findings-section {
            margin: 15px 20px 20px;
            border: 1px solid rgba(0, 212, 255, 0.35);
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.08), rgba(220, 40, 87, 0.08) 45%, var(--bg-card));
            padding: 14px;
            box-shadow: 0 0 0 1px rgba(220, 40, 87, 0.12), 0 8px 20px rgba(0, 0, 0, 0.35);
        }

        .findings-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .findings-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .finding-card {
            border: 1px solid rgba(0, 212, 255, 0.25);
            border-radius: 8px;
            background: linear-gradient(120deg, rgba(10, 14, 20, 0.98), rgba(20, 25, 31, 0.96));
            padding: 10px;
            font-size: 12px;
        }

        .finding-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .finding-badge {
            text-transform: uppercase;
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 700;
            letter-spacing: 0.3px;
        }

        .finding-badge.high {
            color: #fecaca;
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(248, 113, 113, 0.5);
        }

        .finding-badge.medium {
            color: #fde68a;
            background: rgba(245, 158, 11, 0.2);
            border: 1px solid rgba(251, 191, 36, 0.5);
        }

        .finding-badge.low {
            color: #bfdbfe;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(96, 165, 250, 0.5);
        }

        .finding-meta {
            color: var(--text-secondary);
            margin-bottom: 6px;
            line-height: 1.5;
        }

        .finding-impact {
            color: var(--text-primary);
            line-height: 1.5;
            margin-bottom: 6px;
        }

        .finding-evidence {
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .finding-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .finding-btn {
            padding: 6px 10px;
            border-radius: 5px;
            border: 1px solid var(--border);
            font-size: 11px;
            cursor: pointer;
            background: rgba(10, 14, 20, 0.9);
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        .finding-btn:hover {
            border-color: var(--cyan);
            color: var(--cyan);
            background: rgba(0, 212, 255, 0.08);
        }

        .finding-example {
            color: var(--text-muted);
            margin-left: 10px;
        }

        .findings-more-btn {
            margin-top: 8px;
            width: fit-content;
        }

        /* Endpoint tables */
        .endpoint-table {
            width: 100%;
            font-size: 12px;
            margin-top: 10px;
        }

        .endpoint-table th {
            font-size: 10px;
            padding: 8px 6px;
            border-bottom: 1px solid var(--border);
        }

        .endpoint-table td {
            padding: 8px 6px;
            cursor: pointer;
        }

        .endpoint-table tr:hover {
            background: var(--bg-primary);
        }

        .endpoint-address {
            color: var(--cyan);
        }

        /* Security warnings */
        .security-warning {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #dc2626;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
        }

        .security-warning-critical {
            background: rgba(220, 38, 38, 0.15);
            border: 2px solid #ff0000;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
        }

        .warning-title {
            color: #dc2626;
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .warning-title-critical {
            color: #ff0000;
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .warning-details {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .security-ok {
            color: var(--proto-arp);
            font-size: 12px;
        }

        /* Hex dump */
        .hex-dump {
            background: var(--code-bg);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin-top: 8px;
            border: 1px solid var(--border);
            color: var(--text-primary);
            line-height: 1.4;
            white-space: pre;
        }

        .hex-expand-btn {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--cyan);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            margin-top: 8px;
        }

        .hex-expand-btn:hover {
            border-color: var(--crimson);
        }

        /* Footer */
        .viewer-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: var(--bg-card);
            border-top: 1px solid var(--border);
        }

        .btn-reset {
            padding: 10px 20px;
            background: var(--border);
            color: var(--text-secondary);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-reset:hover {
            background: #3d4758;
        }

        .filename {
            color: var(--text-secondary);
            font-size: 12px;
        }

        /* Modal for TCP Stream */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--crimson);
            overflow: hidden;
        }

        .modal-header {
            padding: 20px 25px;
            background: var(--bg-card);
            border-bottom: 2px solid var(--crimson);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            color: var(--text-primary);
            font-size: 18px;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
        }

        .modal-close:hover {
            color: var(--crimson);
        }

        .modal-body {
            padding: 25px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 15px 25px;
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .stream-header {
            background: var(--bg-card);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 12px;
        }

        .stream-header div {
            padding: 4px 0;
            color: var(--text-secondary);
        }

        .stream-header span {
            color: var(--cyan);
            font-weight: 600;
        }

        .stream-content {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-primary);
            white-space: pre;           /* prevents wrapping, enables horizontal scroll */
            max-height: 500px;
            overflow: auto;             /* adds scrollbars when needed */
        }

        .action-btn {
            padding: 10px 20px;
            background: var(--crimson);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .action-btn-secondary {
            background: var(--border);
            color: var(--text-secondary);
        }

        /* Reference Guide Styles */
        .ref-guide {
            display: none;
        }

        .ref-guide.show {
            display: block;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--cyan);
            text-decoration: none;
            font-size: 14px;
            margin-bottom: 20px;
            transition: opacity 0.3s;
        }

        .back-link:hover {
            opacity: 0.8;
        }

        .toc {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 40px;
        }

        .toc h2 {
            font-size: 24px;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .toc-list {
            list-style: none;
            display: grid;
            gap: 15px;
        }

        .toc-item {
            background: var(--bg-card-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            transition: all 0.3s;
        }

        .toc-item:hover {
            border-color: var(--cyan);
            background: rgba(0, 212, 255, 0.05);
        }

        .toc-link {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px 20px;
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 500;
        }

        .toc-icon {
            font-size: 24px;
        }

        .toc-title {
            font-size: 18px;
        }

        .section {
            margin-bottom: 60px;
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }

        .section-icon {
            font-size: 36px;
        }

        .section-title {
            font-size: 36px;
            font-weight: 700;
            color: var(--crimson);
        }

        .subsection {
            margin-bottom: 40px;
        }

        .subsection-title {
            font-size: 24px;
            color: var(--cyan);
            margin-bottom: 25px;
            font-weight: 600;
        }

        /* Enhanced Reference Guide Cards */
        .guide-grid {
            display: grid;
            gap: 25px;
        }

        .guide-card {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 25px;
            transition: all 0.3s;
        }

        .guide-card:hover {
            border-color: var(--cyan);
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.1);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .card-header-icon {
            font-size: 24px;
        }

        .card-header-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .flow-sequence {
            background: var(--bg-card-dark);
            border-radius: 8px;
            padding: 16px;
            margin: 12px 0;
            font-family: 'JetBrains Mono', monospace;
        }

        .flow-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            border-bottom: 1px solid rgba(45, 55, 72, 0.5);
        }

        .flow-item:last-child {
            border-bottom: none;
        }

        .flow-arrow {
            color: var(--crimson);
            font-size: 16px;
            min-width: 30px;
        }

        .flow-text {
            color: var(--text-primary);
            font-size: 14px;
        }

        .flow-desc {
            color: var(--text-secondary);
            font-size: 13px;
            margin-left: 42px;
            margin-top: 4px;
        }

        .tip-box {
            background: rgba(0, 212, 255, 0.05);
            border-left: 3px solid var(--cyan);
            padding: 16px 20px;
            margin: 16px 0;
            border-radius: 0 8px 8px 0;
        }

        .tip-icon {
            color: var(--cyan);
            margin-right: 8px;
        }

        .tip-text {
            color: var(--text-primary);
            font-size: 14px;
            line-height: 1.6;
        }

        .symptoms-box {
            background: rgba(239, 68, 68, 0.05);
            border-left: 3px solid #ef4444;
            padding: 16px 20px;
            margin: 16px 0;
            border-radius: 0 8px 8px 0;
        }

        .symptoms-title {
            color: #ef4444;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .symptoms-list {
            list-style: none;
            padding-left: 24px;
        }

        .symptoms-list li {
            position: relative;
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 6px;
        }

        .symptoms-list li::before {
            content: '‚Ä¢';
            position: absolute;
            left: -16px;
            color: #ef4444;
        }

        .solutions-box {
            background: rgba(63, 185, 80, 0.05);
            border-left: 3px solid var(--green);
            padding: 16px 20px;
            margin: 16px 0;
            border-radius: 0 8px 8px 0;
        }

        .solutions-title {
            color: var(--green);
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .solutions-list {
            list-style: none;
            padding-left: 24px;
        }

        .solutions-list li {
            position: relative;
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 6px;
        }

        .solutions-list li::before {
            content: '‚úì';
            position: absolute;
            left: -20px;
            color: var(--green);
        }

        .prevention-box {
            background: rgba(139, 92, 246, 0.05);
            border-left: 3px solid #8b5cf6;
            padding: 16px 20px;
            margin: 16px 0;
            border-radius: 0 8px 8px 0;
        }

        .prevention-title {
            color: #8b5cf6;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .prevention-list {
            list-style: none;
            padding-left: 24px;
        }

        .prevention-list li {
            position: relative;
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 6px;
        }

        .prevention-list li::before {
            content: 'üõ°Ô∏è';
            position: absolute;
            left: -24px;
        }

        .analysis-box {
            background: rgba(220, 40, 87, 0.05);
            border-left: 3px solid var(--crimson);
            padding: 16px 20px;
            margin: 16px 0;
            border-radius: 0 8px 8px 0;
        }

        .analysis-title {
            color: var(--crimson);
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .reason-codes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 12px;
        }

        .reason-code {
            background: var(--bg-card-dark);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
        }

        .reason-code span {
            color: var(--cyan);
            font-weight: 600;
            margin-right: 8px;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #3d4758;
        }

        html {
            scroll-behavior: smooth;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .split-layout {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .sidebar {
                border-top: 1px solid var(--border);
                border-right: none;
            }
        }

        .hidden {
            display: none !important;
        }
        #pcapViewer .packet-list td:nth-child(2) {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        }
        .packet-list table {
            width: 100%;
            table-layout: fixed;  /* respects the column widths we set */
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Main Tool Section -->
        <div id="mainTool">
            <!-- Header -->
            <header class="header">
                <div class="header-content">
                    <h1>
                        <span class="wire">Voda</span><span class="trace">Trace</span>
                    </h1>
                    <p class="subtitle">PCAP & Event Logs Analysis Tool</p>
                    <p class="attribution">Created by Moaz Essam and Developed by Adam Abushaisha</p>
                    <a href="#" class="reference-btn" onclick="showReferenceGuide(); return false;">
                        üìñ Reference Guide
                    </a>
                </div>
            </header>

            <!-- Mode selector and upload -->
            <div id="uploadSection">
                <div class="mode-selector">
                    <button class="mode-btn" id="pcapBtn" onclick="selectMode('pcap')">
                        üî¨ PCAP PACKET VIEWER
                    </button>
                    <button class="mode-btn event-mode" id="eventlogBtn" onclick="selectMode('eventlog')">
                        üìã EVENT LOG ANALYZER
                    </button>
                </div>

                <div class="drop-zone" id="dropZone">
                    <div class="drop-icon">üìÅ</div>
                    <div class="drop-text">Drop file here or click to browse</div>
                    <div class="drop-hint" id="dropHint">Please select a mode first</div>
                    <input type="file" id="fileInput" style="display: none;">
                </div>

                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressText"></div>
                </div>
            </div>

            <!-- PCAP Viewer -->
            <div class="viewer" id="pcapViewer">
                <div class="toolbar">
                    <input type="text" id="packetFilter" placeholder="Filter (e.g.: 192.168.1.1 or dns)">
                    <select id="protocolFilter">
                        <option value="">All Protocols</option>
                        <option value="Ethernet">Ethernet</option>
                        <option value="VLAN">VLAN</option>
                        <option value="IPv4">IPv4</option>
                        <option value="IPv6">IPv6</option>
                        <option value="ARP">ARP</option>
                        <option value="TCP">TCP</option>
                        <option value="UDP">UDP</option>
                        <option value="ICMP">ICMP</option>
                        <option value="DNS">DNS</option>
                        <option value="DHCP">DHCP</option>
                        <option value="HTTP">HTTP</option>
                        <option value="HTTPS">HTTPS</option>
                        <option value="PPPoE">PPPoE</option>
                        <option value="OTHER">OTHER</option>
                    </select>
                    <button class="btn-apply" onclick="applyPCAPFilters()">Apply</button>
                    <button class="btn-clear" onclick="clearPCAPFilters()">Clear</button>
                    <button class="btn-jump-findings" onclick="jumpToPCAPFindings()">‚Üì Jump to Findings</button>
                    
                    <div class="time-controls">
                        <span class="time-label">Time:</span>
                        <button class="time-btn active" onclick="setTimeFormat('relative')">Relative</button>
                        <button class="time-btn" onclick="setTimeFormat('absolute')">Absolute</button>
                    </div>
                    
                    <select id="displayLimit" onchange="renderPacketTable()">
                        <option value="1000">1,000</option>
                        <option value="5000">5,000</option>
                        <option value="10000">10,000</option>
                        <option value="0">All</option>
                    </select>
                    
                    <span class="packet-count" id="packetCount">0 packets</span>
                </div>

                <div class="split-layout">
                    <div class="packet-list">
                        <table>
                            <thead>
                                <tr>
                                    <th style="width: 50px;">NO.</th>
                                    <th style="width: 170px;">TIME</th>
                                    <th style="width: 130px;">SOURCE</th>
                                    <th style="width: 130px;">DESTINATION</th>
                                    <th style="width: 80px;">PROTOCOL</th>
                                    <th style="width: 60px;">LEN</th>
                                    <th>INFO</th>
                                </tr>
                            </thead>
                            <tbody id="packetTableBody">
                            </tbody>
                        </table>
                    </div>

                    <div class="sidebar">
                        <div class="sidebar-tabs">
                            <div class="sidebar-tab active" onclick="switchSidebarTab('details')">üì¶ Details</div>
                            <div class="sidebar-tab" onclick="switchSidebarTab('endpoints')">üåê Endpoints</div>
                            <div class="sidebar-tab" onclick="switchSidebarTab('security')">üõ°Ô∏è Security</div>
                            <div class="sidebar-tab" onclick="switchSidebarTab('findings')" id="pcapFindingsTabBtn">üß≠ Findings (0)</div>
                        </div>

                        <div class="sidebar-content active" id="detailsTab">
                            <div class="detail-section">
                                <h3>üì¶ Packet Details</h3>
                                <div id="packetDetailsContent">
                                    <p class="text-muted" style="text-align: center; padding: 20px;">Click a packet to view details</p>
                                </div>
                            </div>
                            <div class="detail-section">
                                <h3>üìä Capture Statistics</h3>
                                <div id="pcapStats"></div>
                            </div>
                        </div>

                        <div class="sidebar-content" id="endpointsTab">
                            <div class="detail-section">
                                <h3>üíª IP Endpoints</h3>
                                <div id="ipEndpoints"></div>
                            </div>
                            <div class="detail-section">
                                <h3>üîå MAC Endpoints</h3>
                                <div id="macEndpoints"></div>
                            </div>
                        </div>

                        <div class="sidebar-content" id="securityTab">
                            <div class="detail-section">
                                <h3>üõ°Ô∏è Rogue Device Detection</h3>
                                <div id="rogueDevicesContent">
                                    <p class="security-ok">‚úÖ No suspicious devices detected</p>
                                </div>
                            </div>
                        </div>

                        <div class="sidebar-content" id="findingsTab">
                            <div class="detail-section">
                                <h3>üß≠ Investigation Findings</h3>
                                <div id="pcapFindingsContent"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <section id="pcapFindingsSection" class="findings-section">
                    <div id="pcapFindingsContent"></div>
                </section>

                <div class="viewer-footer">
                    <button class="btn-reset" onclick="reset()">üîÑ Load New File</button>
                    <span class="filename" id="currentFilename"></span>
                </div>
            </div>

            <!-- Event Log Viewer -->
            <div class="viewer" id="eventViewer">
                <div class="toolbar">
                    <input type="text" id="eventFilter" placeholder="Filter by text, MAC address, category...">
                    <select id="categoryFilter">
                        <option value="">All Categories</option>
                    </select>
                    <select id="severityFilter">
                        <option value="">All Severities</option>
                    </select>
                    <button class="btn-apply" onclick="applyEventFilters()">Apply</button>
                    <button class="btn-clear" onclick="clearEventFilters()">Clear</button>
                    <button class="btn-jump-findings" onclick="jumpToFindings()">‚Üì Jump to Findings</button>
                    <select id="eventDisplayLimit" onchange="renderEventTable()">
                        <option value="1000">1,000</option>
                        <option value="5000">5,000</option>
                        <option value="10000">10,000</option>
                        <option value="0">All</option>
                    </select>
                    <span class="packet-count" id="eventCount">0 events</span>
                </div>

                <div class="split-layout">
                    <div class="packet-list">
                        <table>
                            <thead>
                                <tr>
                                    <th style="width: 50px;">#</th>
                                    <th style="width: 200px;">DATE/TIME</th>
                                    <th style="width: 100px;">CATEGORY</th>
                                    <th style="width: 100px;">SEVERITY</th>
                                    <th>DETAILS</th>
                                </tr>
                            </thead>
                            <tbody id="eventTableBody">
                            </tbody>
                        </table>
                    </div>

                    <div class="sidebar">
                        <div class="sidebar-content active">
                            <div class="detail-section">
                                <h3>üìã Event Details</h3>
                                <div id="eventDetailsContent">
                                    <p class="text-muted" style="text-align: center; padding: 20px;">Click an event to view details</p>
                                </div>
                            </div>
                            <div class="detail-section">
                                <h3>üìä Pattern Analysis</h3>
                                <div id="eventPatterns"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="viewer-footer">
                    <button class="btn-reset" onclick="reset()">üîÑ Load New File</button>
                    <span class="filename" id="eventFilename"></span>
                </div>

                <section id="findingsSection" class="findings-section">
                    <div id="findingsContent"></div>
                </section>
            </div>
        </div>

        <!-- TCP Stream Modal -->
        <div id="tcpStreamModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>üîó TCP Stream Viewer</h2>
                    <button class="modal-close" onclick="closeStreamModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <div id="streamInfo" class="stream-header"></div>
                    <div id="streamData" class="stream-content"></div>
                </div>
                <div class="modal-footer">
                    <button class="action-btn" onclick="exportTCPStream()">üíæ Export Stream</button>
                    <button class="action-btn-secondary action-btn" onclick="closeStreamModal()">Close</button>
                </div>
            </div>
        </div>

        <!-- Reference Guide Section -->
        <div id="referenceGuide" class="ref-guide">
            <header class="header">
                <div class="header-content">
                    <a href="#" class="back-link" onclick="showMainTool(); return false;">
                        ‚Üê Back to VodaTrace
                    </a>
                    <h1>
                        <span class="wire">Voda</span><span class="trace">Trace</span> Reference Guide
                    </h1>
                    <p class="subtitle">Network Analysis Terminology & Data Interpretation</p>
                </div>
            </header>

            <!-- Table of Contents -->
            <nav class="toc">
                <h2>üìë Table of Contents</h2>
                <ul class="toc-list">
                    <li class="toc-item">
                        <a href="#jargon-buster" class="toc-link">
                            <span class="toc-icon">üî§</span>
                            <span class="toc-title">Jargon Buster</span>
                        </a>
                    </li>
                    <li class="toc-item">
                        <a href="#data-interpretation" class="toc-link">
                            <span class="toc-icon">üìä</span>
                            <span class="toc-title">Data Interpretation Guide</span>
                        </a>
                    </li>
                </ul>
            </nav>

            <!-- Section 1: Jargon Buster (Expanded) -->
            <section id="jargon-buster" class="section">
                <div class="section-header">
                    <span class="section-icon">üî§</span>
                    <h2 class="section-title">Jargon Buster</h2>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">PCAP & Network Terms</h3>
                    <div class="guide-grid">
                        <!-- PCAP -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üì¶</span>
                                <span class="card-header-title">PCAP (Packet Capture)</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: A file format used to store network packet data captured from a network interface.</span>
                                </div>
                                <div class="flow-desc">Context: Used by tools like Wireshark, tcpdump, and WireTrace for offline analysis.</div>
                                <div class="flow-desc">Example: A <code>.pcap</code> file containing 10,000 packets captured over 5 minutes.</div>
                            </div>
                        </div>

                        <!-- Packet -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üì®</span>
                                <span class="card-header-title">Packet</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: A formatted unit of data carried across a network, containing headers and payload.</span>
                                </div>
                                <div class="flow-desc">Context: Each row in the PCAP viewer represents one packet.</div>
                                <div class="flow-desc">Example: An HTTP GET request is a single packet with TCP, IP, and Ethernet headers.</div>
                            </div>
                        </div>

                        <!-- Protocol -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üîå</span>
                                <span class="card-header-title">Protocol</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: A set of rules defining how data is formatted and transmitted (e.g., TCP, UDP, DNS).</span>
                                </div>
                                <div class="flow-desc">Context: Packets are classified by protocol in the Protocol column.</div>
                                <div class="flow-desc">Example: DNS protocol packets handle domain name resolution.</div>
                            </div>
                        </div>

                        <!-- MAC Address -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üî¢</span>
                                <span class="card-header-title">MAC Address</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: A unique 48-bit hardware identifier assigned to a network interface controller.</span>
                                </div>
                                <div class="flow-desc">Context: Found in Ethernet frame headers; used for local network communication.</div>
                                <div class="flow-desc">Example: <code>00:1A:2B:3C:4D:5E</code> ‚Äî uniquely identifies a device on the LAN.</div>
                            </div>
                        </div>

                        <!-- ARP -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üîÑ</span>
                                <span class="card-header-title">ARP (Address Resolution Protocol)</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: Protocol mapping IP addresses to MAC addresses on a local network.</span>
                                </div>
                                <div class="flow-desc">Context: ARP packets reveal which devices are communicating on the LAN.</div>
                                <div class="flow-desc">Example: 'Who has 192.168.1.1? Tell 192.168.1.100' ‚Äî device asking for the router's MAC.</div>
                            </div>
                        </div>

                        <!-- DNS -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üåê</span>
                                <span class="card-header-title">DNS (Domain Name System)</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: Protocol that resolves human-readable domain names to IP addresses.</span>
                                </div>
                                <div class="flow-desc">Context: DNS queries/responses show which websites or services devices are accessing.</div>
                                <div class="flow-desc">Example: Query: 'What is the IP of google.com?' ‚Üí Response: '142.250.80.46'</div>
                            </div>
                        </div>

                        <!-- DHCP -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üè†</span>
                                <span class="card-header-title">DHCP (Dynamic Host Configuration Protocol)</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: Protocol that automatically assigns IP addresses and network config to devices.</span>
                                </div>
                                <div class="flow-desc">Context: DHCP Discover/Offer/Request/ACK sequences show devices joining the network.</div>
                                <div class="flow-desc">Example: DHCP Offer from 192.168.1.1 assigns IP 192.168.1.50 to a new device.</div>
                            </div>
                        </div>

                        <!-- TCP -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üîÑ</span>
                                <span class="card-header-title">TCP (Transmission Control Protocol)</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: Connection-oriented protocol providing reliable, ordered data delivery.</span>
                                </div>
                                <div class="flow-desc">Context: Most web traffic uses TCP. SYN/ACK/FIN flags show connection lifecycle.</div>
                                <div class="flow-desc">Example: TCP SYN from port 52341 ‚Üí port 443 initiates an HTTPS connection.</div>
                            </div>
                        </div>

                        <!-- UDP -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">‚ö°</span>
                                <span class="card-header-title">UDP (User Datagram Protocol)</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: Connectionless protocol offering fast, lightweight data transmission without guaranteed delivery.</span>
                                </div>
                                <div class="flow-desc">Context: Used by DNS, DHCP, streaming, gaming, and VoIP.</div>
                                <div class="flow-desc">Example: DNS queries typically use UDP port 53 for speed.</div>
                            </div>
                        </div>

                        <!-- ICMP -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üì¢</span>
                                <span class="card-header-title">ICMP (Internet Control Message Protocol)</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: Protocol for diagnostic and error messages between network devices.</span>
                                </div>
                                <div class="flow-desc">Context: Ping requests/replies and traceroute use ICMP.</div>
                                <div class="flow-desc">Example: Echo Request (Type 8) from 192.168.1.5 to 8.8.8.8 ‚Äî testing connectivity.</div>
                            </div>
                        </div>

                        <!-- PPPoE -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üì°</span>
                                <span class="card-header-title">PPPoE (Point-to-Point Protocol over Ethernet)</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: Protocol for encapsulating PPP frames inside Ethernet, commonly used by ISPs.</span>
                                </div>
                                <div class="flow-desc">Context: PADI/PADO/PADR/PADS sequences indicate broadband connection establishment.</div>
                                <div class="flow-desc">Example: PADI (PPPoE Active Discovery Initiation) ‚Äî router trying to connect to ISP.</div>
                            </div>
                        </div>

                        <!-- VLAN -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üîÄ</span>
                                <span class="card-header-title">VLAN (Virtual Local Area Network)</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: A logical subdivision of a LAN, tagged with an ID in the 802.1Q header.</span>
                                </div>
                                <div class="flow-desc">Context: VLAN IDs in packet captures show network segmentation.</div>
                                <div class="flow-desc">Example: VLAN 100 for data traffic, VLAN 200 for voice traffic.</div>
                            </div>
                        </div>

                        <!-- TTL -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">‚è±Ô∏è</span>
                                <span class="card-header-title">TTL (Time To Live)</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: Counter in IP headers decremented at each router hop; packet discarded when it reaches zero.</span>
                                </div>
                                <div class="flow-desc">Context: Helps identify routing loops and estimate distance to remote hosts.</div>
                                <div class="flow-desc">Example: TTL=64 suggests the packet originated from a Linux/Mac device.</div>
                            </div>
                        </div>

                        <!-- ARP Spoofing -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">‚ö†Ô∏è</span>
                                <span class="card-header-title">ARP Spoofing</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üìÑ</span>
                                    <span class="flow-text">Definition: An attack where a device sends forged ARP replies to associate its MAC with another device's IP.</span>
                                </div>
                                <div class="flow-desc">Context: WireTrace's Security tab detects this ‚Äî critical MITM attack indicator.</div>
                                <div class="flow-desc">Example: Device <code>00:AB:CD:EF:12:34</code> falsely claims to be 192.168.1.1 (the gateway).</div>
                            </div>
                        </div>

                        <!-- Linux SLL -->
                        <div class="guide-card">
                            <div class="card-header">
                                <span class="card-header-icon">üêß</span>
                                <span class="card-header-title">Linux SLL (Linux cooked-mode capture)</span>
                            </div>
                            <div class="flow-sequence">
                                <div class="flow-item">
                                    <span class="flow-arrow">üîß</span>
                                    <span class="flow-text">Definition: A special packet header format used when capturing on Linux "any" interface.</span>
                                </div>
                                <div class="flow-desc">Context: When tcpdump uses <code>-i any</code>, all packets get an SLL header wrapping the real protocols underneath.</div>
                                <div class="flow-desc">Example: Source MAC address is extracted from the SLL header.</div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Section 2: Data Interpretation Guide -->
            <section id="data-interpretation" class="section">
                <div class="section-header">
                    <span class="section-icon">üìä</span>
                    <h2 class="section-title">Data Interpretation Guide</h2>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Reading PCAP Data</h3>
                    
                    <!-- TCP Connection Lifecycle -->
                    <div class="guide-card">
                        <div class="card-header">
                            <span class="card-header-icon">üîÑ</span>
                            <span class="card-header-title">TCP Connection Lifecycle</span>
                        </div>
                        <div class="flow-sequence">
                            <div class="flow-item">
                                <span class="flow-arrow">SYN</span>
                                <span class="flow-text">‚Üí Client initiates connection</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">SYN-ACK</span>
                                <span class="flow-text">‚Üí Server acknowledges and accepts</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">ACK</span>
                                <span class="flow-text">‚Üí Client confirms ‚Äî connection established</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">FIN</span>
                                <span class="flow-text">‚Üí Either side closes connection</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">RST</span>
                                <span class="flow-text">‚Üí Connection reset (abrupt termination)</span>
                            </div>
                        </div>
                        <div class="tip-box">
                            <span class="tip-icon">üîç</span>
                            <span class="tip-text"><strong>What to look for:</strong> Multiple RST packets to the same destination suggest a service is unavailable or a firewall is blocking.</span>
                        </div>
                    </div>

                    <!-- DNS Resolution Flow -->
                    <div class="guide-card">
                        <div class="card-header">
                            <span class="card-header-icon">üåê</span>
                            <span class="card-header-title">DNS Resolution Flow</span>
                        </div>
                        <div class="flow-sequence">
                            <div class="flow-item">
                                <span class="flow-arrow">Query</span>
                                <span class="flow-text">‚Üí Device asks "What is the IP for example.com?"</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">Response (No error)</span>
                                <span class="flow-text">‚Üí Server returns the IP address</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">Response (Name error)</span>
                                <span class="flow-text">‚Üí Domain doesn't exist (NXDOMAIN)</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">Response (Server failure)</span>
                                <span class="flow-text">‚Üí DNS server couldn't process the request</span>
                            </div>
                        </div>
                        <div class="tip-box">
                            <span class="tip-icon">üîç</span>
                            <span class="tip-text"><strong>What to look for:</strong> Frequent Server Failure responses indicate DNS server issues. Name errors for internal domains suggest misconfiguration.</span>
                        </div>
                    </div>

                    <!-- DHCP Handshake (DORA) -->
                    <div class="guide-card">
                        <div class="card-header">
                            <span class="card-header-icon">üè†</span>
                            <span class="card-header-title">DHCP Handshake (DORA)</span>
                        </div>
                        <div class="flow-sequence">
                            <div class="flow-item">
                                <span class="flow-arrow">Discover</span>
                                <span class="flow-text">‚Üí Client broadcasts: "I need an IP address"</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">Offer</span>
                                <span class="flow-text">‚Üí Server responds: "You can have 192.168.1.50"</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">Request</span>
                                <span class="flow-text">‚Üí Client: "I'll take 192.168.1.50"</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">ACK</span>
                                <span class="flow-text">‚Üí Server: "Confirmed, it's yours for 24h"</span>
                            </div>
                        </div>
                        <div class="tip-box">
                            <span class="tip-icon">üîç</span>
                            <span class="tip-text"><strong>What to look for:</strong> Missing Offer after Discover suggests DHCP server is down. Multiple Discovers indicate the client can't get an address.</span>
                        </div>
                    </div>

                    <!-- PPPoE Session Setup -->
                    <div class="guide-card">
                        <div class="card-header">
                            <span class="card-header-icon">üì°</span>
                            <span class="card-header-title">PPPoE Session Setup</span>
                        </div>
                        <div class="flow-sequence">
                            <div class="flow-item">
                                <span class="flow-arrow">PADI</span>
                                <span class="flow-text">‚Üí Router initiates ISP discovery</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">PADO</span>
                                <span class="flow-text">‚Üí ISP responds with service offer</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">PADR</span>
                                <span class="flow-text">‚Üí Router requests specific service</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">PADS</span>
                                <span class="flow-text">‚Üí ISP confirms session established</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">PADT</span>
                                <span class="flow-text">‚Üí Either side terminates session</span>
                            </div>
                        </div>
                        <div class="tip-box">
                            <span class="tip-icon">üîç</span>
                            <span class="tip-text"><strong>What to look for:</strong> PADI without PADO means the ISP is unreachable. Frequent PADT indicates unstable broadband connection.</span>
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Reading Event Logs</h3>
                    
                    <!-- WiFi Disconnection Patterns -->
                    <div class="guide-card">
                        <div class="card-header">
                            <span class="card-header-icon">üì∂</span>
                            <span class="card-header-title">WiFi Disconnection Patterns</span>
                        </div>
                        <div class="flow-sequence">
                            <div class="flow-item">
                                <span class="flow-arrow">‚Ä¢</span>
                                <span class="flow-text">Repeated DEAUTH for one MAC ‚Üí Device-specific issue (driver, distance, interference)</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">‚Ä¢</span>
                                <span class="flow-text">DEAUTH storms across many MACs ‚Üí AP overloaded or under deauth attack</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">‚Ä¢</span>
                                <span class="flow-text">DEAUTH Reason=1 ‚Üí Unspecified reason</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">‚Ä¢</span>
                                <span class="flow-text">DEAUTH Reason=3 ‚Üí Leaving the network (normal)</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">‚Ä¢</span>
                                <span class="flow-text">DEAUTH Reason=7 ‚Üí Not authenticated</span>
                            </div>
                        </div>
                        <div class="tip-box">
                            <span class="tip-icon">üîç</span>
                            <span class="tip-text"><strong>Tip:</strong> Cross-reference with PCAP data to see if the device's traffic shows issues before disconnection.</span>
                        </div>
                    </div>

                    <!-- WAN Event Patterns -->
                    <div class="guide-card">
                        <div class="card-header">
                            <span class="card-header-icon">üåç</span>
                            <span class="card-header-title">WAN Event Patterns</span>
                        </div>
                        <div class="flow-sequence">
                            <div class="flow-item">
                                <span class="flow-arrow">‚Ä¢</span>
                                <span class="flow-text">PPPoE PADI sequences ‚Üí Router attempting to re-establish ISP connection</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">‚Ä¢</span>
                                <span class="flow-text">Failed to create socket ‚Üí Critical: networking stack failure</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-arrow">‚Ä¢</span>
                                <span class="flow-text">Link Up/Down events ‚Üí Physical line issues (cable, exchange, weather)</span>
                            </div>
                        </div>
                        <div class="tip-box">
                            <span class="tip-icon">üîç</span>
                            <span class="tip-text"><strong>Tip:</strong> Check timestamps of WAN events against reported outage times.</span>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </div>

    <script>
        // Global state
        let mode = null;
        let allPackets = [];
        let filteredPackets = [];
        let allEvents = [];
        let filteredEvents = [];
        let selectedItem = null;
        let timeDisplayFormat = 'relative';
        let pcapFirstTimestamp = null;
        let stats = {};
        let currentEventStats = null;
        let findingsVisibleCount = 10;
        let activeFindingFilter = null;
        let pcapFindings = [];
        let pcapFindingsSummary = { total: 0, high: 0, medium: 0, low: 0 };
        
        // Enhanced PCAP analysis
        let ipEndpoints = new Map();
        let macEndpoints = new Map();
        let tcpStreams = new Map();
        let rogueDevices = [];
        let hexDumpExpanded = false;
        let legitimateGatewayMAC = null;

        // All possible protocols for filtering
        const ALL_PROTOCOLS = [
            'Ethernet', 'SLL', 'VLAN', 'IPv4', 'IPv6', 'ARP', 'TCP', 'UDP', 
            'ICMP', 'DNS', 'DHCP', 'HTTP', 'HTTPS', 'PPPoE', 'OTHER'
        ];

        const PCAP_FINDING_THRESHOLDS = {
            TCP_FAILED_HANDSHAKE_SYN: 20,
            TCP_RST_THRESHOLD: 50,
            TCP_DUP_SYN_WINDOW_SEC: 3,
            DNS_NXDOMAIN_THRESHOLD: 10,
            DNS_UNANSWERED_THRESHOLD: 10,
            DHCP_BURST_THRESHOLD: 20,
            ARP_GATEWAY_REQUEST_THRESHOLD: 30,
            PPPOE_PADI_THRESHOLD: 10,
            PPPOE_PADT_THRESHOLD: 1,
            ONE_WAY_RATIO_THRESHOLD: 50,
            MAX_PACKET_NOS: 10,
            MAX_EXAMPLES: 5
        };

        // Show/hide sections
        function showReferenceGuide() {
            document.getElementById('mainTool').style.display = 'none';
            document.getElementById('referenceGuide').classList.add('show');
            window.scrollTo(0, 0);
        }

        function showMainTool() {
            document.getElementById('referenceGuide').classList.remove('show');
            document.getElementById('mainTool').style.display = 'block';
            window.scrollTo(0, 0);
        }

        // Mode selection
        function selectMode(selectedMode) {
            mode = selectedMode;
            document.getElementById('pcapBtn').classList.toggle('active', mode === 'pcap');
            document.getElementById('eventlogBtn').classList.toggle('active', mode === 'eventlog');
            
            const fileInput = document.getElementById('fileInput');
            const dropHint = document.getElementById('dropHint');
            
            if (mode === 'pcap') {
                fileInput.accept = '.pcap,.pcapng';
                dropHint.textContent = 'Supported: .pcap, .pcapng';
            } else {
                fileInput.accept = '.log,.csv,.txt';
                dropHint.textContent = 'Supported: .log, .csv, .txt';
            }
        }

        // File handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            if (mode && e.dataTransfer.files[0]) {
                processFile(e.dataTransfer.files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (mode && e.target.files[0]) {
                processFile(e.target.files[0]);
            }
        });

        function showProgress(show) {
            document.getElementById('progressContainer').classList.toggle('show', show);
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        async function processFile(file) {
            if (!mode) {
                alert('Please select a mode first!');
                return;
            }

            const ext = file.name.toLowerCase().split('.').pop();
            
            if (mode === 'pcap' && !['pcap', 'pcapng'].includes(ext)) {
                alert('Please select a PCAP file (.pcap or .pcapng)');
                return;
            }
            
            if (mode === 'eventlog' && !['log', 'csv', 'txt'].includes(ext)) {
                alert('Please select an event log file (.log, .csv, or .txt)');
                return;
            }

            showProgress(true);
            updateProgress(0, `Loading ${file.name}...`);

            try {
                if (mode === 'pcap') {
                    const buffer = await file.arrayBuffer();
                    await analyzePCAP(buffer, file.name);
                } else {
                    const text = await file.text();
                    await analyzeEventLog(text, file.name);
                }
            } catch (error) {
                console.error('Error:', error);
                alert(`Error: ${error.message}`);
                showProgress(false);
            }
        }

        // ============================================
        // PCAP PARSING
        // ============================================

        async function analyzePCAP(buffer, filename) {
            console.time('PCAP Parsing');
            updateProgress(5, 'Reading PCAP header...');

            const view = new DataView(buffer);
            
            // Detect endianness
            const magic_le = view.getUint32(0, true);
            const magic_be = view.getUint32(0, false);
            
            let isLittleEndian;
            if (magic_le === 0xa1b2c3d4) {
                isLittleEndian = true;
            } else if (magic_be === 0xa1b2c3d4) {
                isLittleEndian = false;
            } else {
                throw new Error(`Invalid PCAP magic number`);
            }

            const linkType = view.getUint32(20, isLittleEndian);
            console.log(`PCAP Link Type: ${linkType}`);

            allPackets = [];
            ipEndpoints.clear();
            macEndpoints.clear();
            tcpStreams.clear();
            rogueDevices = [];
            pcapFindings = [];
            pcapFindingsSummary = { total: 0, high: 0, medium: 0, low: 0 };
            legitimateGatewayMAC = null;
            hexDumpExpanded = false;
            let offset = 24;
            let packetCount = 0;
            let firstPacketAbsTime = null;
            const maxPackets = 1000000;
            const batchSize = 500;

            updateProgress(10, 'Parsing packets...');

            try {
                while (offset < buffer.byteLength - 16 && packetCount < maxPackets) {
                    let batchCount = 0;
                    
                    while (batchCount < batchSize && offset < buffer.byteLength - 16) {
                        const tsSec = view.getUint32(offset, isLittleEndian);
                        const tsUsec = view.getUint32(offset + 4, isLittleEndian);
                        const inclLen = view.getUint32(offset + 8, isLittleEndian);
                        const origLen = view.getUint32(offset + 12, isLittleEndian);

                        if (inclLen === 0 || inclLen > 65535 || offset + 16 + inclLen > buffer.byteLength) {
                            offset += 16;
                            continue;
                        }

                        if (inclLen < 14) {
                            offset += 16 + inclLen;
                            continue;
                        }

                        const absTimestamp = tsSec + (tsUsec / 1000000);
                        if (firstPacketAbsTime === null) {
                            firstPacketAbsTime = absTimestamp;
                            pcapFirstTimestamp = firstPacketAbsTime;
                        }

                        const relativeTime = absTimestamp - firstPacketAbsTime;

                        const packetData = buffer.slice(offset + 16, offset + 16 + inclLen);
                        
                        try {
                            const packet = parsePacket(packetData, packetCount + 1, absTimestamp, relativeTime, linkType);
                            packet.rawData = packetData;
                            packet.absTimestamp = absTimestamp;
                            packet.relativeTime = relativeTime;
                            allPackets.push(packet);
                            
                            // Track endpoints and detect rogue devices
                            trackEndpoint(packet);
                        } catch (parseError) {
                            const errorPacket = {
                                no: packetCount + 1,
                                absTimestamp: absTimestamp,
                                relativeTime: relativeTime,
                                timestamp: relativeTime.toFixed(6),
                                length: inclLen,
                                protocol: 'ERROR',
                                source: 'Parse Error',
                                destination: 'N/A',
                                info: `Failed to parse: ${parseError.message}`,
                                layers: {}
                            };
                            allPackets.push(errorPacket);
                        }

                        packetCount++;
                        batchCount++;
                        offset += 16 + inclLen;
                    }
                    
                    if (packetCount % 1000 === 0 || packetCount < 1000) {
                        const progress = 10 + (offset / buffer.byteLength) * 85;
                        const mbProcessed = (offset / 1024 / 1024).toFixed(1);
                        const mbTotal = (buffer.byteLength / 1024 / 1024).toFixed(1);
                        updateProgress(progress, `Parsed ${packetCount.toLocaleString()} packets (${mbProcessed} MB of ${mbTotal} MB)`);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
            } catch (error) {
                console.error('Parsing error:', error);
                updateProgress(100, `Error: ${error.message}. Parsed ${packetCount} packets`);
            }

            updateProgress(95, 'Calculating statistics...');

            stats = calculatePCAPStatistics(allPackets, filename, allPackets.length > 0 ? allPackets[allPackets.length - 1].relativeTime : 0);

            // Run ARP spoofing detection
            detectARPSpoofingFromPackets();

            const findingsResult = analyzePCAPFindings(allPackets, stats);
            pcapFindings = findingsResult.findings;
            pcapFindingsSummary = findingsResult.summary;
            
            updateProgress(100, `Complete! Loaded ${allPackets.length.toLocaleString()} packets`);
            console.timeEnd('PCAP Parsing');

            displayPCAPViewer();
            renderEndpoints();
            setTimeout(() => showProgress(false), 500);
        }

        function parsePacket(buffer, number, absTimestamp, relativeTime, linkType) {
            const packet = {
                no: number,
                absTimestamp: absTimestamp,
                relativeTime: relativeTime,
                timestamp: relativeTime.toFixed(6),
                length: buffer.byteLength,
                protocol: 'UNKNOWN',
                source: '',
                destination: '',
                info: '',
                layers: {},
                rawData: buffer
            };

            if (linkType === 1) {
                return parseEthernet(buffer, 0, packet);
            } else if (linkType === 113) {
                return parseLinuxSLL(buffer, 0, packet);
            } else {
                packet.protocol = 'UNSUPPORTED';
                packet.info = `Link type: ${linkType}`;
                return packet;
            }
        }

        function parseLinuxSLL(buffer, offset, packet) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 16) {
                throw new Error('Truncated SLL header');
            }

            const packetType = view.getUint16(offset, false);
            const arphrdType = view.getUint16(offset + 2, false);
            const addrLen = view.getUint16(offset + 4, false);
            const protocolType = view.getUint16(offset + 14, false);

            // Extract MAC address if present
            let sourceMAC = '';
            if (addrLen >= 6) {
                const addrBytes = new Uint8Array(buffer, offset + 6, 6);
                sourceMAC = Array.from(addrBytes).map(b => b.toString(16).padStart(2, '0')).join(':');
            }

            packet.layers.sll = {
                packetType: getSLLPacketType(packetType),
                arphrdType: arphrdType,
                addressLength: addrLen,
                protocolType: `0x${protocolType.toString(16).padStart(4, '0')}`,
                sourceAddress: sourceMAC
            };

            packet.source = sourceMAC || `${packet.layers.sll.packetType}`;
            packet.destination = 'Linux SLL';
            // REMOVED: packet.protocol = 'SLL'; - Let parseEtherType set the actual protocol

            const payloadOffset = offset + 16;
            
            if (protocolType === 0x8100 && buffer.byteLength >= payloadOffset + 4) {
                return parseVLAN(buffer, payloadOffset, packet, packet.source, packet.destination);
            }

            return parseEtherType(protocolType, buffer, payloadOffset, packet, packet.source, packet.destination);
        }

        function getSLLPacketType(type) {
            const types = {
                0: 'To us',
                1: 'Broadcast',
                2: 'Multicast',
                3: 'Other host',
                4: 'Outgoing'
            };
            return types[type] || `Type ${type}`;
        }

        function parseEthernet(buffer, offset, packet) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 14) {
                throw new Error('Truncated Ethernet frame');
            }

            const dstMAC = formatMAC(buffer, offset);
            const srcMAC = formatMAC(buffer, offset + 6);
            const ethType = view.getUint16(offset + 12, false);

            packet.layers.ethernet = {
                destination: dstMAC,
                source: srcMAC,
                type: `0x${ethType.toString(16).padStart(4, '0')}`
            };

            packet.source = srcMAC;
            packet.destination = dstMAC;
            packet.protocol = 'Ethernet';

            const payloadOffset = offset + 14;

            if (ethType === 0x8100 && buffer.byteLength >= offset + 18) {
                return parseVLAN(buffer, offset + 14, packet, srcMAC, dstMAC);
            }

            return parseEtherType(ethType, buffer, payloadOffset, packet, srcMAC, dstMAC);
        }

        function parseVLAN(buffer, offset, packet, src, dst) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 4) {
                throw new Error('Truncated VLAN tag');
            }

            const vlanTCI = view.getUint16(offset, false);
            const vlanId = vlanTCI & 0x0FFF;
            const nextProtocol = view.getUint16(offset + 2, false);

            packet.layers.vlan = {
                id: vlanId,
                priority: (vlanTCI >> 13) & 0x07
            };

            packet.protocol = 'VLAN';
            const payloadOffset = offset + 4;
            packet.info = `VLAN ${vlanId} - `;
            
            return parseEtherType(nextProtocol, buffer, payloadOffset, packet, src, dst);
        }

        function parseEtherType(ethType, buffer, offset, packet, src, dst) {
            switch (ethType) {
                case 0x0800:
                    return parseIPv4(buffer, offset, packet, src, dst);
                case 0x0806:
                    return parseARP(buffer, offset, packet);
                case 0x86dd:
                    return parseIPv6(buffer, offset, packet);
                case 0x8863:
                    return parsePPPoE(buffer, offset, packet, 'Discovery');
                case 0x8864:
                    return parsePPPoE(buffer, offset, packet, 'Session');
                default:
                    packet.protocol = 'OTHER';
                    packet.source = src;
                    packet.destination = dst;
                    packet.info += `EtherType: 0x${ethType.toString(16).padStart(4, '0')}`;
                    return packet;
            }
        }

        function parseIPv4(buffer, offset, packet, src, dst) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 20) {
                throw new Error('Truncated IPv4 header');
            }

            const versionIHL = view.getUint8(offset);
            const version = (versionIHL & 0xF0) >> 4;
            const ihl = (versionIHL & 0x0F) * 4;

            if (version !== 4) {
                throw new Error(`Invalid IP version: ${version}`);
            }

            const protocol = view.getUint8(offset + 9);
            const srcIP = [
                view.getUint8(offset + 12),
                view.getUint8(offset + 13),
                view.getUint8(offset + 14),
                view.getUint8(offset + 15)
            ].join('.');
            const dstIP = [
                view.getUint8(offset + 16),
                view.getUint8(offset + 17),
                view.getUint8(offset + 18),
                view.getUint8(offset + 19)
            ].join('.');

            packet.layers.ip = {
                version: 4,
                headerLength: ihl,
                protocol: protocol,
                source: srcIP,
                destination: dstIP
            };

            packet.protocol = 'IPv4';
            packet.source = srcIP;
            packet.destination = dstIP;

            const ipPayloadOffset = offset + ihl;

            switch (protocol) {
                case 6:
                    return parseTCP(buffer, ipPayloadOffset, packet, srcIP, dstIP);
                case 17:
                    return parseUDP(buffer, ipPayloadOffset, packet, srcIP, dstIP);
                case 1:
                    return parseICMP(buffer, ipPayloadOffset, packet, srcIP, dstIP);
                default:
                    packet.info = `Protocol: ${protocol}`;
            }

            return packet;
        }

        function parseIPv6(buffer, offset, packet) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 40) {
                throw new Error('Truncated IPv6 header');
            }

            const srcIP = extractIPv6Address(buffer, offset + 8);
            const dstIP = extractIPv6Address(buffer, offset + 24);
            const nextHeader = view.getUint8(offset + 6);

            packet.layers.ipv6 = {
                version: 6,
                nextHeader: nextHeader,
                source: srcIP,
                destination: dstIP
            };

            packet.protocol = 'IPv6';
            packet.source = srcIP;
            packet.destination = dstIP;
            packet.info = `IPv6 Next: ${nextHeader}`;

            return packet;
        }

        function extractIPv6Address(buffer, offset) {
            const bytes = new Uint8Array(buffer, offset, 16);
            const parts = [];
            for (let i = 0; i < 16; i += 2) {
                parts.push((bytes[i] << 8 | bytes[i + 1]).toString(16));
            }
            return parts.join(':');
        }

        function parseTCP(buffer, offset, packet, srcIP, dstIP) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 20) {
                throw new Error('Truncated TCP header');
            }

            const srcPort = view.getUint16(offset, false);
            const dstPort = view.getUint16(offset + 2, false);
            const seqNum = view.getUint32(offset + 4, false);
            const ackNum = view.getUint32(offset + 8, false);
            const flags = view.getUint8(offset + 13);

            packet.layers.tcp = {
                sourcePort: srcPort,
                destinationPort: dstPort,
                sequenceNumber: seqNum,
                acknowledgmentNumber: ackNum,
                flags: {
                    fin: !!(flags & 0x01),
                    syn: !!(flags & 0x02),
                    rst: !!(flags & 0x04),
                    psh: !!(flags & 0x08),
                    ack: !!(flags & 0x10),
                    urg: !!(flags & 0x20)
                }
            };

            packet.protocol = 'TCP';
            packet.source = `${srcIP}:${srcPort}`;
            packet.destination = `${dstIP}:${dstPort}`;

            const flagStr = [];
            if (flags & 0x02) flagStr.push('SYN');
            if (flags & 0x10) flagStr.push('ACK');
            if (flags & 0x01) flagStr.push('FIN');
            if (flags & 0x04) flagStr.push('RST');

            if (srcPort === 80 || dstPort === 80 || srcPort === 443 || dstPort === 443) {
                packet.protocol = srcPort === 443 || dstPort === 443 ? 'HTTPS' : 'HTTP';
                packet.info = `${packet.protocol} ${flagStr.join(', ')}`;
            } else {
                packet.info = `${srcPort} ‚Üí ${dstPort} [${flagStr.join(', ')}]`;
            }

            return packet;
        }

        function parseUDP(buffer, offset, packet, srcIP, dstIP) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 8) {
                throw new Error('Truncated UDP header');
            }

            const srcPort = view.getUint16(offset, false);
            const dstPort = view.getUint16(offset + 2, false);
            const length = view.getUint16(offset + 4, false);

            packet.layers.udp = {
                sourcePort: srcPort,
                destinationPort: dstPort,
                length: length
            };

            packet.protocol = 'UDP';
            packet.source = `${srcIP}:${srcPort}`;
            packet.destination = `${dstIP}:${dstPort}`;

            const payloadOffset = offset + 8;

            if (srcPort === 53 || dstPort === 53) {
                return parseDNS(buffer, payloadOffset, packet);
            } else if ((srcPort === 67 || srcPort === 68) && (dstPort === 67 || dstPort === 68)) {
                return parseDHCP(buffer, payloadOffset, packet);
            } else {
                packet.info = `${srcPort} ‚Üí ${dstPort} Len=${length}`;
            }

            return packet;
        }

        function parseDNS(buffer, offset, packet) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 12) {
                packet.protocol = 'DNS';
                packet.info = 'Truncated DNS';
                return packet;
            }

            const transactionId = view.getUint16(offset, false);
            const flags = view.getUint16(offset + 2, false);
            const questions = view.getUint16(offset + 4, false);
            const answerRRs = view.getUint16(offset + 6, false);

            const qr = (flags & 0x8000) >>> 15;
            const rcode = flags & 0x000F;

            packet.layers.dns = {
                transactionId: `0x${transactionId.toString(16)}`,
                isResponse: qr === 1,
                responseCode: rcode,
                questions: questions,
                answers: answerRRs
            };

            packet.protocol = 'DNS';
            
            if (qr === 0) {
                packet.info = `Query (${questions} question${questions !== 1 ? 's' : ''})`;
            } else {
                const rcodes = ['No error', 'Format error', 'Server failure', 'Name error'];
                packet.info = `Response (${rcodes[rcode] || `Code ${rcode}`}, ${answerRRs} answer${answerRRs !== 1 ? 's' : ''})`;
            }

            return packet;
        }

        function parseDHCP(buffer, offset, packet) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 240) {
                packet.protocol = 'DHCP';
                packet.info = 'Truncated DHCP';
                return packet;
            }

            const op = view.getUint8(offset);
            const xid = view.getUint32(offset + 4, false);

            let optOffset = offset + 240;
            let messageType = 0;
            let foundOption125 = false;

            while (optOffset < buffer.byteLength - 2) {
                const optType = view.getUint8(optOffset);
                if (optType === 255) break;
                if (optType === 0) {
                    optOffset++;
                    continue;
                }

                const optLen = view.getUint8(optOffset + 1);
                
                if (optType === 53 && optLen === 1) {
                    messageType = view.getUint8(optOffset + 2);
                }
                
                if (optType === 125) {
                    foundOption125 = true;
                }

                optOffset += 2 + optLen;
            }

            const messageTypes = {
                1: 'Discover',
                2: 'Offer',
                3: 'Request',
                4: 'Decline',
                5: 'ACK',
                6: 'NAK',
                7: 'Release',
                8: 'Inform'
            };

            packet.layers.dhcp = {
                operation: op === 1 ? 'Request' : 'Reply',
                transactionId: `0x${xid.toString(16)}`,
                messageType: messageTypes[messageType] || 'Unknown',
                option125: foundOption125
            };

            packet.protocol = 'DHCP';
            packet.info = `${messageTypes[messageType] || 'Unknown'}${foundOption125 ? ' - Opt 125' : ''}`;

            return packet;
        }

        function parseICMP(buffer, offset, packet, srcIP, dstIP) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 8) {
                throw new Error('Truncated ICMP header');
            }

            const type = view.getUint8(offset);
            const code = view.getUint8(offset + 1);

            const icmpTypes = {
                0: 'Echo Reply',
                3: 'Destination Unreachable',
                8: 'Echo Request',
                11: 'Time Exceeded'
            };

            packet.layers.icmp = {
                type: type,
                code: code,
                typeName: icmpTypes[type] || `Type ${type}`
            };

            packet.protocol = 'ICMP';
            packet.source = srcIP;
            packet.destination = dstIP;
            packet.info = icmpTypes[type] || `Type ${type}, Code ${code}`;

            return packet;
        }

        function parseARP(buffer, offset, packet) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 28) {
                throw new Error('Truncated ARP packet');
            }

            const oper = view.getUint16(offset + 6, false);
            
            const sha = formatMAC(buffer, offset + 8);
            const spa = readIPv4(view, offset + 14);
            const tha = formatMAC(buffer, offset + 18);
            const tpa = readIPv4(view, offset + 24);

            packet.layers.arp = {
                operation: oper === 1 ? 'Request' : 'Reply',
                senderMAC: sha,
                senderIP: spa,
                targetMAC: tha,
                targetIP: tpa
            };

            packet.protocol = 'ARP';
            packet.source = sha;
            packet.destination = tha;

            if (oper === 1) {
                packet.info = `Who has ${tpa}? Tell ${spa}`;
            } else if (oper === 2) {
                packet.info = `${spa} is at ${sha}`;
            }

            return packet;
        }

        function parsePPPoE(buffer, offset, packet, stage) {
            const view = new DataView(buffer);
            
            if (buffer.byteLength < offset + 6) {
                throw new Error('Truncated PPPoE header');
            }

            const versionType = view.getUint8(offset);
            const code = view.getUint8(offset + 1);
            const sessionId = view.getUint16(offset + 2, false);

            packet.layers.pppoe = {
                version: (versionType & 0xF0) >> 4,
                type: versionType & 0x0F,
                code: code,
                sessionId: sessionId,
                stage: stage
            };

            const codenames = {
                0x00: 'Session Data',
                0x09: 'PADI',
                0x07: 'PADO',
                0x19: 'PADR',
                0x65: 'PADS',
                0xa7: 'PADT'
            };

            packet.protocol = 'PPPoE';
            const codeName = codenames[code] || `Code 0x${code.toString(16)}`;
            packet.info = `${codeName} - Session ${sessionId}`;

            return packet;
        }

        function formatMAC(buffer, offset) {
            try {
                const bytes = new Uint8Array(buffer, offset, 6);
                return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(':');
            } catch {
                return '00:00:00:00:00:00';
            }
        }

        function readIPv4(view, offset) {
            return [
                view.getUint8(offset),
                view.getUint8(offset + 1),
                view.getUint8(offset + 2),
                view.getUint8(offset + 3)
            ].join('.');
        }

        function calculatePCAPStatistics(packets, filename, duration) {
            const stats = {
                filename: filename,
                totalPackets: packets.length,
                duration: duration ? duration.toFixed(2) + 's' : 'N/A',
                avgRate: duration > 0 ? (packets.length / duration).toFixed(1) + ' pkt/s' : 'N/A',
                protocols: {},
                vlanIds: new Set(),
                pppoe: { padi: 0, pado: 0, padr: 0, pads: 0, padt: 0, session: 0 }
            };

            packets.forEach(packet => {
                stats.protocols[packet.protocol] = (stats.protocols[packet.protocol] || 0) + 1;
                
                if (packet.layers.vlan) {
                    stats.vlanIds.add(packet.layers.vlan.id);
                }
                
                if (packet.protocol === 'PPPoE' && packet.layers.pppoe) {
                    const code = packet.layers.pppoe.code;
                    if (code === 0x09) stats.pppoe.padi++;
                    else if (code === 0x07) stats.pppoe.pado++;
                    else if (code === 0x19) stats.pppoe.padr++;
                    else if (code === 0x65) stats.pppoe.pads++;
                    else if (code === 0xa7) stats.pppoe.padt++;
                    else if (code === 0x00) stats.pppoe.session++;
                }
            });

            stats.vlanIds = Array.from(stats.vlanIds).sort((a, b) => a - b);

            return stats;
        }

        function findLegitimateGatewayMACFromPackets() {
            console.log("Looking for legitimate gateway MAC...");
            
            // Common gateway IP patterns
            const gatewayPatterns = [
                /\.1$/, /\.254$/, /\.2$/, /\.253$/,  // Common endings
                /^192\.168\.1\.1$/, /^192\.168\.0\.1$/, /^10\.0\.0\.1$/, /^10\.0\.1\.1$/  // Exact matches
            ];
            
            // Strategy 1: Look for DHCP Offers from gateway IPs
            for (const packet of allPackets) {
                if (packet.protocol === 'DHCP' && packet.info && packet.info.includes('Offer')) {
                    const srcIP = packet.layers?.ip?.source;
                    if (srcIP) {
                        // Check if this IP matches gateway patterns
                        const isGateway = gatewayPatterns.some(pattern => pattern.test(srcIP));
                        if (isGateway) {
                            // Get MAC from this DHCP packet
                            if (packet.layers?.ethernet?.source) {
                                console.log(`Found gateway MAC from DHCP: ${packet.layers.ethernet.source}`);
                                return packet.layers.ethernet.source;
                            } else if (packet.layers?.sll?.sourceAddress) {
                                console.log(`Found gateway MAC from DHCP (SLL): ${packet.layers.sll.sourceAddress}`);
                                return packet.layers.sll.sourceAddress;
                            }
                        }
                    }
                }
            }
            
            // Strategy 2: Find the most common MAC claiming gateway IPs in ARP replies
            const macCounts = {};
            for (const packet of allPackets) {
                if (packet.protocol === 'ARP' && packet.layers?.arp) {
                    const arp = packet.layers.arp;
                    if (arp.operation === 'Reply') {
                        const senderIP = arp.senderIP;
                        const senderMAC = arp.senderMAC;
                        
                        // Check if it's a gateway IP
                        const isGateway = gatewayPatterns.some(pattern => pattern.test(senderIP));
                        if (isGateway && senderMAC) {
                            macCounts[senderMAC] = (macCounts[senderMAC] || 0) + 1;
                        }
                    }
                }
            }
            
            // Return the most common MAC
            if (Object.keys(macCounts).length > 0) {
                const sorted = Object.entries(macCounts).sort((a, b) => b[1] - a[1]);
                console.log(`Found legitimate gateway MAC candidates:`, sorted);
                return sorted[0][0];
            }
            
            // Strategy 3: If no gateway found, use the most active MAC as a fallback
            if (macEndpoints.size > 0) {
                const sortedMACs = Array.from(macEndpoints.entries())
                    .sort((a, b) => (b[1].sent + b[1].recv) - (a[1].sent + a[1].recv));
                if (sortedMACs.length > 0) {
                    console.log(`No gateway found, using most active MAC: ${sortedMACs[0][0]}`);
                    return sortedMACs[0][0];
                }
            }
            
            return null;
        }

        function detectARPSpoofingFromPackets() {
            console.log("üîç Running ARP spoofing detection...");
            
            // First find the legitimate gateway MAC
            legitimateGatewayMAC = findLegitimateGatewayMACFromPackets();
            console.log(`Legitimate Gateway MAC: ${legitimateGatewayMAC}`);
            
            // Track all ARP replies to detect flooding and spoofing
            const arpReplies = new Map(); // MAC -> count
            const arpRequests = new Map(); // IP being queried -> count
            
            // Now check all ARP packets for spoofing and flooding
            for (const packet of allPackets) {
                if (packet.protocol === 'ARP' && packet.layers?.arp) {
                    const arp = packet.layers.arp;
                    const srcMAC = arp.senderMAC;
                    const senderIP = arp.senderIP;
                    const targetIP = arp.targetIP;
                    
                    // Track ARP replies for flooding detection
                    if (arp.operation === 'Reply') {
                        arpReplies.set(srcMAC, (arpReplies.get(srcMAC) || 0) + 1);
                        console.log(`ARP Reply from ${srcMAC} claiming ${senderIP}`); // Debug log
                        
                        // Check for ARP spoofing (claiming to be gateway)
                        if (legitimateGatewayMAC) {
                            const isGatewayIP = 
                                senderIP.endsWith('.1') || 
                                senderIP.endsWith('.254') ||
                                senderIP.endsWith('.2') ||
                                senderIP === '192.168.1.1' ||
                                senderIP === '192.168.0.1' ||
                                senderIP === '10.0.0.1';
                            
                            if (isGatewayIP) {
                                console.log(`Gateway IP claimed by ${srcMAC}`); // Debug log
                                // Check if the MAC matches the legitimate gateway MAC
                                if (srcMAC.toLowerCase() !== legitimateGatewayMAC.toLowerCase()) {
                                    // This is ARP spoofing!
                                    const existing = rogueDevices.find(r => 
                                        r.mac === srcMAC && 
                                        r.type === 'arp_spoof' &&
                                        r.spoofedIP === senderIP
                                    );
                                    
                                    if (!existing) {
                                        console.warn(`üö® ARP SPOOFING DETECTED: ${srcMAC} claiming to be ${senderIP} (real: ${legitimateGatewayMAC})`);
                                        rogueDevices.push({
                                            type: 'arp_spoof',
                                            mac: srcMAC,
                                            ip: senderIP,
                                            spoofedIP: senderIP,
                                            legitimateMAC: legitimateGatewayMAC,
                                            description: `ARP Spoofing - Device ${srcMAC} claiming to be gateway ${senderIP}`,
                                            severity: 'critical',
                                            details: `MITM Attack! Device impersonating gateway. Real MAC: ${legitimateGatewayMAC}`
                                        });
                                    }
                                }
                            }
                        }
                    }
                    
                    // Track ARP requests for flooding detection
                    if (arp.operation === 'Request') {
                        arpRequests.set(targetIP, (arpRequests.get(targetIP) || 0) + 1);
                    }
                }
            }
            
            console.log("ARP Reply counts:", Object.fromEntries(arpReplies)); // Debug log
            
            // Check for ARP flooding (more than 30 replies from same MAC)
            for (const [mac, count] of arpReplies.entries()) {
                if (count > 30) {
                    // Try to find an IP for this MAC
                    let deviceIP = 'Unknown';
                    for (const packet of allPackets) {
                        if (packet.protocol === 'ARP' && packet.layers?.arp && packet.layers.arp.senderMAC === mac) {
                            deviceIP = packet.layers.arp.senderIP;
                            break;
                        }
                    }
                    
                    const existing = rogueDevices.find(r => r.mac === mac && (r.type === 'arp_flood' || r.type === 'arp_scan'));
                    if (!existing) {
                        console.log(`üö® ARP FLOODING DETECTED: ${mac} (${deviceIP}) sent ${count} replies`);
                        rogueDevices.push({
                            type: 'arp_flood',
                            mac: mac,
                            ip: deviceIP,
                            description: `ARP Flooding - Device sent ${count} ARP replies`,
                            severity: 'high',
                            details: `Excessive ARP traffic (${count} replies) from ${mac} (${deviceIP}). This may indicate network scanning or ARP cache poisoning.`
                        });
                    }
                }
            }

            // Check for devices sending ARP replies for multiple different IPs (ARP cache poisoning attempt)
            const replySources = new Map(); // MAC -> Set of IPs they claimed
            for (const packet of allPackets) {
                if (packet.protocol === 'ARP' && packet.layers?.arp && packet.layers.arp.operation === 'Reply') {
                    const arp = packet.layers.arp;
                    const mac = arp.senderMAC;
                    const ip = arp.senderIP;
                    
                    if (!replySources.has(mac)) {
                        replySources.set(mac, new Set());
                    }
                    replySources.get(mac).add(ip);
                }
            }

            // Check for devices claiming multiple IPs
            for (const [mac, ips] of replySources.entries()) {
                if (ips.size >= 3) { // Device claiming 3 or more different IPs
                    // Skip if it's the legitimate gateway
                    if (legitimateGatewayMAC && mac.toLowerCase() === legitimateGatewayMAC.toLowerCase()) {
                        continue;
                    }
                    
                    const existing = rogueDevices.find(r => r.mac === mac && r.type === 'arp_scan');
                    if (!existing) {
                        const ipList = Array.from(ips).join(', ');
                        const firstIP = Array.from(ips)[0] || 'Unknown';
                        console.log(`üö® ARP SCAN DETECTED: ${mac} claiming ${ips.size} different IPs: ${ipList}`);
                        rogueDevices.push({
                            type: 'arp_scan',
                            mac: mac,
                            ip: firstIP,
                            description: `ARP Scan - Device claiming ${ips.size} different IPs`,
                            severity: 'medium',
                            details: `Device ${mac} is claiming multiple IP addresses: ${ipList}. This may indicate ARP cache poisoning or network scanning.`
                        });
                    }
                }
            }

            // Check for ARP request scanning (many requests for different IPs)
            const requestSources = new Map(); // MAC -> Set of IPs they asked about
            for (const packet of allPackets) {
                if (packet.protocol === 'ARP' && packet.layers?.arp && packet.layers.arp.operation === 'Request') {
                    // Get source MAC from ethernet or SLL layer
                    let srcMAC = '';
                    if (packet.layers?.ethernet) {
                        srcMAC = packet.layers.ethernet.source;
                    } else if (packet.layers?.sll && packet.layers.sll.sourceAddress) {
                        srcMAC = packet.layers.sll.sourceAddress;
                    }
                    
                    if (srcMAC) {
                        const targetIP = packet.layers.arp.targetIP;
                        if (!requestSources.has(srcMAC)) {
                            requestSources.set(srcMAC, new Set());
                        }
                        requestSources.get(srcMAC).add(targetIP);
                    }
                }
            }

            // Check for devices scanning many IPs
            for (const [mac, ips] of requestSources.entries()) {
                if (ips.size > 30) { // Device asked about more than 30 different IPs
                    const existing = rogueDevices.find(r => r.mac === mac && r.type === 'arp_scan');
                    if (!existing) {
                        console.log(`üö® ARP SCAN DETECTED: ${mac} scanned ${ips.size} IPs`);
                        rogueDevices.push({
                            type: 'arp_scan',
                            mac: mac,
                            ip: 'Unknown',
                            description: `ARP Scan - Device scanned ${ips.size} IPs`,
                            severity: 'medium',
                            details: `Device ${mac} sent ARP requests for ${ips.size} different IP addresses, indicating network reconnaissance.`
                        });
                    }
                }
            }
            
            // Check for ARP scans (many requests for different IPs from same source)
            if (arpRequests.size > 50) {
                console.log(`ARP scan detected: ${arpRequests.size} unique IPs queried`);
            }
            
            console.log(`Rogue devices detected: ${rogueDevices.length}`);
            if (rogueDevices.length > 0) {
                console.log("Rogue devices:", rogueDevices);
                // Force re-render of security tab
                renderRogueDevices();
                
                // If we're already on security tab, update it; otherwise it will update when clicked
                if (document.querySelector('.sidebar-tab.active').textContent.includes('Security')) {
                    // Already on security tab, content will update
                }
            }
        }

        function trackEndpoint(packet) {
            const macRegex = /^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$/;
            
            // Track MAC addresses
            if (packet.source && macRegex.test(packet.source)) {
                updateMACEndpoint(packet.source, 'sent', packet.length);
            }
            if (packet.destination && macRegex.test(packet.destination)) {
                updateMACEndpoint(packet.destination, 'recv', packet.length);
            }

            // Track IP addresses from packet.layers.ip
            if (packet.layers?.ip) {
                const srcIP = packet.layers.ip.source;
                const dstIP = packet.layers.ip.destination;
                
                if (srcIP) updateIPEndpoint(srcIP, 'sent', packet.length, packet.protocol);
                if (dstIP) updateIPEndpoint(dstIP, 'recv', packet.length, packet.protocol);
            }

            // Track for rogue device detection
            detectRogueDevices(packet);
        }

        function updateIPEndpoint(ip, direction, bytes, protocol) {
            if (!ipEndpoints.has(ip)) {
                ipEndpoints.set(ip, {
                    address: ip,
                    sent: 0,
                    recv: 0,
                    sentBytes: 0,
                    recvBytes: 0,
                    protocols: new Set()
                });
            }

            const endpoint = ipEndpoints.get(ip);
            if (direction === 'sent') {
                endpoint.sent++;
                endpoint.sentBytes += bytes;
            } else {
                endpoint.recv++;
                endpoint.recvBytes += bytes;
            }
            endpoint.protocols.add(protocol);
        }

        function updateMACEndpoint(mac, direction, bytes) {
            if (!macEndpoints.has(mac)) {
                macEndpoints.set(mac, {
                    address: mac,
                    sent: 0,
                    recv: 0,
                    sentBytes: 0,
                    recvBytes: 0,
                    protocols: new Set()
                });
            }

            const endpoint = macEndpoints.get(mac);
            if (direction === 'sent') {
                endpoint.sent++;
                endpoint.sentBytes += bytes;
            } else {
                endpoint.recv++;
                endpoint.recvBytes += bytes;
            }
        }

        function detectRogueDevices(packet) {
            // Check for DHCP servers (offering IPs)
            if (packet.protocol === 'DHCP' && packet.info && packet.info.includes('Offer')) {
                const srcIP = packet.layers?.ip?.source;
                
                // Get MAC address from the correct layer
                let srcMAC = '';
                if (packet.layers?.ethernet) {
                    srcMAC = packet.layers.ethernet.source;
                } else if (packet.layers?.sll && packet.layers.sll.sourceAddress) {
                    srcMAC = packet.layers.sll.sourceAddress;
                }
                
                if (srcIP && srcMAC) {
                    // Only flag as rogue if it's NOT a typical gateway IP
                    const isLikelyGateway = 
                        srcIP.endsWith('.1') || 
                        srcIP.endsWith('.254') ||
                        srcIP.endsWith('.2') ||
                        srcIP.endsWith('.253');
                    
                    // For private IP ranges
                    const isPrivateIP = 
                        srcIP.startsWith('192.168.') ||
                        srcIP.startsWith('10.') ||
                        (srcIP.startsWith('172.') && 
                         parseInt(srcIP.split('.')[1]) >= 16 && 
                         parseInt(srcIP.split('.')[1]) <= 31);
                    
                    // Only flag as rogue if it's NOT a typical gateway IP AND it's in a private range
                    if ((!isLikelyGateway && isPrivateIP) || !isPrivateIP) {
                        const existing = rogueDevices.find(r => r.mac === srcMAC && r.type === 'dhcp');
                        if (!existing) {
                            rogueDevices.push({
                                type: 'dhcp',
                                mac: srcMAC,
                                ip: srcIP,
                                description: 'Potential rogue DHCP server detected',
                                severity: 'high'
                            });
                        }
                    }
                }
            }

            // Check for DNS responses from non-gateway IPs
            if (packet.protocol === 'DNS' && packet.info && packet.info.includes('response')) {
                const srcIP = packet.layers?.ip?.source;
                let srcMAC = '';
                if (packet.layers?.ethernet) {
                    srcMAC = packet.layers.ethernet.source;
                } else if (packet.layers?.sll && packet.layers.sll.sourceAddress) {
                    srcMAC = packet.layers.sll.sourceAddress;
                }
                
                // Only flag if it's NOT a typical gateway and NOT a known DNS server
                if (srcIP && srcMAC && !srcIP.endsWith('.1') && !srcIP.endsWith('.254')) {
                    const knownDNSServers = ['8.8.8.8', '8.8.4.4', '1.1.1.1', '1.0.0.1'];
                    if (!knownDNSServers.includes(srcIP)) {
                        const existing = rogueDevices.find(r => r.mac === srcMAC && r.type === 'dns');
                        if (!existing) {
                            rogueDevices.push({
                                type: 'dns',
                                mac: srcMAC,
                                ip: srcIP,
                                description: 'Non-gateway device sending DNS responses',
                                severity: 'medium'
                            });
                        }
                    }
                }
            }
        }

        // ============================================
        // PCAP DISPLAY
        // ============================================

        function populateProtocolFilter() {
            const select = document.getElementById('protocolFilter');
            const protocols = [...new Set(allPackets.map(p => p.protocol))].sort();
            
            select.innerHTML = '<option value="">All Protocols</option>';
            protocols.forEach(p => {
                // Skip empty protocols
                if (!p) return;
                const opt = document.createElement('option');
                opt.value = p;
                opt.textContent = p;
                select.appendChild(opt);
            });
        }

        function displayPCAPViewer() {
            document.getElementById('eventViewer').classList.remove('show');
            document.getElementById('pcapViewer').classList.add('show');
            document.getElementById('uploadSection').style.display = 'none';

            filteredPackets = allPackets;
            renderPacketTable();
            updatePCAPStatistics();
            populateProtocolFilter();
            renderPCAPFindings();
        }

        function renderPacketTable() {
            const tbody = document.getElementById('packetTableBody');
            tbody.innerHTML = '';

            const limit = parseInt(document.getElementById('displayLimit').value);
            const packetsToShow = limit === 0 ? filteredPackets : filteredPackets.slice(0, limit);

            packetsToShow.forEach(packet => {
                const row = document.createElement('tr');
                row.className = selectedItem?.no === packet.no ? 'selected' : '';
                row.onclick = () => selectPacket(packet);

                row.innerHTML = `
                    <td class="text-muted">${packet.no}</td>
                    <td class="text-muted" title="${timeDisplayFormat === 'relative' ? 'Relative time: ' + packet.timestamp + ' seconds' : 'Absolute time: ' + new Date(packet.absTimestamp * 1000).toLocaleString()}">
                        ${formatTimeForDisplay(packet.timestamp, packet.absTimestamp)}
                    </td>
                    <td class="truncate" title="${packet.source}">${truncate(packet.source, 30)}</td>
                    <td class="truncate" title="${packet.destination}">${truncate(packet.destination, 30)}</td>
                    <td class="protocol protocol-${packet.protocol.toLowerCase()}">${packet.protocol}</td>
                    <td class="text-muted">${packet.length}</td>
                    <td class="truncate" title="${packet.info}">${truncate(packet.info, 50)}</td>
                `;

                tbody.appendChild(row);
            });

            if (filteredPackets.length > packetsToShow.length) {
                const row = document.createElement('tr');
                row.innerHTML = `<td colspan="7" style="text-align: center; color: var(--text-secondary); padding: 15px;">
                    ‚ö†Ô∏è Displaying ${packetsToShow.length.toLocaleString()} of ${filteredPackets.length.toLocaleString()} packets
                </td>`;
                tbody.appendChild(row);
            }

            document.getElementById('packetCount').textContent = `${filteredPackets.length.toLocaleString()} packets`;
        }

        function selectPacket(packet) {
            selectedItem = packet;
            renderPacketTable();
            displayPacketDetails(packet);
        }

        function displayPacketDetails(packet) {
            const content = document.getElementById('packetDetailsContent');
            
            let html = `<div class="layer-section">
                <div class="layer-title">Frame ${packet.no}</div>
                <div class="detail-row">
                    <span class="detail-label">Length</span>
                    <span class="detail-value">${packet.length} bytes</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Relative Time</span>
                    <span class="detail-value">${packet.timestamp} s</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Absolute Time</span>
                    <span class="detail-value">${new Date(packet.absTimestamp * 1000).toISOString()}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Protocol</span>
                    <span class="detail-value protocol-${packet.protocol.toLowerCase()}">${packet.protocol}</span>
                </div>
            </div>`;

            // Add TCP Stream button if this is a TCP packet
            if (packet.protocol === 'TCP' || packet.layers?.tcp) {
                html += `<div style="margin: 15px 0;">
                    <button class="action-btn" style="width: 100%;" onclick="followTCPStream(${packet.no})">
                        üîó Follow TCP Stream
                    </button>
                </div>`;
            }

            for (const layer in packet.layers) {
                html += `<div class="layer-section">
                    <div class="layer-title">${layer.toUpperCase()}</div>`;
                
                const layerData = packet.layers[layer];
                for (const field in layerData) {
                    if (typeof layerData[field] === 'object') {
                        html += `<div class="layer-field">${field}:</div>`;
                        for (const subfield in layerData[field]) {
                            html += `<div class="layer-field" style="margin-left: 15px;">${subfield}: <span>${layerData[field][subfield]}</span></div>`;
                        }
                    } else {
                        html += `<div class="layer-field">${field}: <span>${layerData[field]}</span></div>`;
                    }
                }
                html += `</div>`;
            }

            if (packet.rawData && packet.rawData.byteLength > 0) {
                const maxBytes = hexDumpExpanded ? packet.rawData.byteLength : 128;
                const hexDump = generateHexDump(packet.rawData, maxBytes);
                html += `<div class="layer-section">
                    <div class="layer-title">Hex Dump (${packet.rawData.byteLength} bytes total)</div>
                    <div class="hex-dump">${hexDump}</div>
                    ${packet.rawData.byteLength > 128 ? `
                        <button class="hex-expand-btn" onclick="toggleHexDump(${packet.no})">
                            ${hexDumpExpanded ? 'üì¶ Show Less (128 bytes)' : `üìÇ Show All Bytes (${packet.rawData.byteLength} bytes)`}
                        </button>
                    ` : ''}
                </div>`;
            }

            content.innerHTML = html;
        }

        function generateHexDump(buffer, maxBytes) {
            const bytes = new Uint8Array(buffer);
            const length = Math.min(bytes.length, maxBytes);
            
            let dump = '';
            const bytesPerLine = 16;

            for (let i = 0; i < length; i += bytesPerLine) {
                const offset = i.toString(16).padStart(4, '0');
                const hex = [];
                const ascii = [];

                for (let j = 0; j < bytesPerLine && i + j < length; j++) {
                    const byte = bytes[i + j];
                    hex.push(byte.toString(16).padStart(2, '0'));
                    ascii.push(byte >= 32 && byte < 127 ? String.fromCharCode(byte) : '.');
                }

                dump += `${offset}  ${hex.join(' ').padEnd(3 * bytesPerLine - 1, ' ')}  ${ascii.join('')}\n`;
            }

            if (bytes.length > maxBytes && maxBytes < bytes.length) {
                dump += `\n... (${bytes.length - maxBytes} more bytes)`;
            }

            return dump;
        }

        function updatePCAPStatistics() {
            const html = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Total Packets</div>
                        <div class="stat-value">${stats.totalPackets?.toLocaleString() || 0}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Duration</div>
                        <div class="stat-value">${stats.duration || 'N/A'}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Avg Rate</div>
                        <div class="stat-value">${stats.avgRate || 'N/A'}</div>
                    </div>
                </div>
                <div class="protocol-list">
                    <h4 style="color: var(--text-secondary); font-size: 11px; margin: 15px 0 10px;">PROTOCOLS</h4>
                    ${stats.protocols ? Object.entries(stats.protocols)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 8)
                        .map(([proto, count]) => {
                            const pct = ((count / stats.totalPackets) * 100).toFixed(1);
                            return `<div class="protocol-item">
                                <span class="protocol protocol-${proto.toLowerCase()}">${proto}</span>
                                <span>${count.toLocaleString()} (${pct}%)</span>
                            </div>`;
                        }).join('') : '<p class="text-muted">No protocol data</p>'}
                </div>
            `;

            document.getElementById('pcapStats').innerHTML = html;
        }

        function renderEndpoints() {
            const ipList = Array.from(ipEndpoints.values())
                .sort((a, b) => (b.sent + b.recv) - (a.sent + a.recv))
                .slice(0, 15);
            
            document.getElementById('ipEndpoints').innerHTML = ipList.length ? `
                <table class="endpoint-table">
                    <thead><tr><th>Address</th><th>Packets</th><th>Bytes</th></tr></thead>
                    <tbody>
                        ${ipList.map(ep => `
                            <tr onclick="filterByIP('${ep.address}')">
                                <td class="endpoint-address">${ep.address}</td>
                                <td>${(ep.sent + ep.recv).toLocaleString()}</td>
                                <td>${formatBytes(ep.sentBytes + ep.recvBytes)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            ` : '<p class="text-muted">No IP endpoints</p>';

            const macList = Array.from(macEndpoints.values())
                .sort((a, b) => (b.sent + b.recv) - (a.sent + a.recv))
                .slice(0, 15);
            
            document.getElementById('macEndpoints').innerHTML = macList.length ? `
                <table class="endpoint-table">
                    <thead><tr><th>Address</th><th>Packets</th><th>Bytes</th></tr></thead>
                    <tbody>
                        ${macList.map(ep => `
                            <tr onclick="filterByMAC('${ep.address}')">
                                <td class="endpoint-address">${ep.address}</td>
                                <td>${(ep.sent + ep.recv).toLocaleString()}</td>
                                <td>${formatBytes(ep.sentBytes + ep.recvBytes)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            ` : '<p class="text-muted">No MAC endpoints</p>';

            // Render rogue devices
            renderRogueDevices();
        }

        function renderRogueDevices() {
            const content = document.getElementById('rogueDevicesContent');
            
            if (rogueDevices.length === 0) {
                content.innerHTML = '<p class="security-ok">‚úÖ No suspicious devices detected</p>';
                return;
            }

            let html = '';
            rogueDevices.forEach(device => {
                const isCritical = device.severity === 'critical';
                const warningClass = isCritical ? 'security-warning-critical' : 'security-warning';
                const titleClass = isCritical ? 'warning-title-critical' : 'warning-title';
                
                html += `
                    <div class="${warningClass}">
                        <div class="${titleClass}">
                            ‚ö†Ô∏è ${device.description}
                        </div>
                        <div class="warning-details">
                            ${device.mac ? `<strong>MAC:</strong> ${device.mac}<br>` : ''}
                            <strong>IP:</strong> ${device.ip}<br>
                            <strong>Type:</strong> ${device.type.toUpperCase()}<br>
                            ${device.legitimateMAC ? `<strong>Legitimate Gateway MAC:</strong> ${device.legitimateMAC}<br>` : ''}
                            <strong>Severity:</strong> ${device.severity.toUpperCase()}
                        </div>
                    </div>
                `;
            });

            content.innerHTML = html;
        }

        function filterByIP(ip) {
            document.getElementById('packetFilter').value = ip;
            applyPCAPFilters();
            switchSidebarTab('details');
        }

        function filterByMAC(mac) {
            document.getElementById('packetFilter').value = mac;
            applyPCAPFilters();
            switchSidebarTab('details');
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function formatTimeForDisplay(timestamp, absTimestamp) {
            if (timeDisplayFormat === 'absolute') {
                if (!absTimestamp) return timestamp;
                const date = new Date(absTimestamp * 1000);
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');
                const milliseconds = String(Math.floor((absTimestamp % 1) * 1000)).padStart(3, '0');
                return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}`;
            } else {
                // Format exactly as in screenshot: 0.000000 (no 's' suffix)
                return parseFloat(timestamp).toFixed(6);
            }
        }

        function setTimeFormat(format) {
            timeDisplayFormat = format;
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase() === format);
            });
            renderPacketTable();
        }

        function switchSidebarTab(tab) {
            const tabMap = {
                details: { button: 0, panel: 'detailsTab' },
                endpoints: { button: 1, panel: 'endpointsTab' },
                security: { button: 2, panel: 'securityTab' }
            };

            document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.sidebar-content').forEach(c => c.classList.remove('active'));

            const target = tabMap[tab] || tabMap.details;
            const tabs = document.querySelectorAll('.sidebar-tab');
            if (tabs[target.button]) tabs[target.button].classList.add('active');
            const panel = document.getElementById(target.panel);
            if (panel) panel.classList.add('active');
        }


        function renderPCAPFindings() {
            const container = document.getElementById('pcapFindingsContent');
            if (!container) return;

            if (!pcapFindings || pcapFindings.length === 0) {
                container.innerHTML = `
                    <div class="findings-title"><strong>üß≠ Investigation Findings (0)</strong></div>
                    <p class="text-muted">No suspicious patterns detected.</p>
                `;
                return;
            }

            const summary = `<div class="findings-title"><strong>üß≠ Investigation Findings (${pcapFindingsSummary.total})</strong><span class="text-muted" style="font-size:11px;">High ${pcapFindingsSummary.high} ‚Ä¢ Medium ${pcapFindingsSummary.medium} ‚Ä¢ Low ${pcapFindingsSummary.low}</span></div>`;
            container.innerHTML = summary + `<div class="findings-list">` + pcapFindings.map(finding => `
                <article class="finding-card" style="margin-bottom:10px;">
                    <div class="finding-header">
                        <div><strong>${finding.title}</strong> <span class="text-muted">(${finding.category})</span></div>
                        ${findingBadge(finding.severity)}
                    </div>
                    <div class="finding-impact">${finding.impact}</div>
                    <div class="finding-meta">${(finding.affected || []).map(item => [item.ip, item.mac, item.port, item.note].filter(Boolean).join(' ‚Ä¢ ')).join('<br>') || 'Affected entities not resolved'}</div>
                    <div class="finding-evidence"><strong>Evidence:</strong> ${finding.evidence.count} packets ‚Ä¢ ${finding.evidence.firstSeen} ‚Üí ${finding.evidence.lastSeen}<br>
                        ${(finding.evidence.examples || []).map(ex => `<div class="finding-example">#${ex.no}: ${ex.summary}</div>`).join('')}
                    </div>
                    <div class="finding-actions">
                        <button class="finding-btn" onclick="applyPCAPFindingAction('${finding.id}')">Filter packets</button>
                        ${finding.actions && finding.actions.jumpToPacketNo ? `<button class="finding-btn" onclick="jumpToPCAPPacket(${finding.actions.jumpToPacketNo})">Jump to example</button>` : ''}
                    </div>
                </article>
            `).join('') + `</div>`;
        }

        function applyPCAPFindingAction(findingId) {
            const finding = pcapFindings.find(item => item.id === findingId);
            if (!finding) return;
            document.getElementById('packetFilter').value = finding.actions?.filterText || '';
            document.getElementById('protocolFilter').value = finding.actions?.protocol || '';
            applyPCAPFilters();
        }

        function jumpToPCAPPacket(packetNo) {
            const packet = allPackets.find(p => p.no === packetNo);
            if (!packet) return;
            selectPacket(packet);
            switchSidebarTab('details');
        }

        function jumpToPCAPFindings() {
            const panel = document.getElementById('pcapFindingsSection');
            if (panel) panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function summarizePacket(packet) {
            return `${packet.protocol} ${packet.source} ‚Üí ${packet.destination} ${truncate(packet.info || '', 70)}`;
        }

        function pushUniqueLimited(list, value, max) {
            if (value === undefined || value === null) return;
            if (!list.includes(value) && list.length < max) list.push(value);
        }

        function analyzePCAPFindings(packets, stats) {
            const findings = [];
            const byIP = new Map();
            const byMAC = new Map();
            const flows = new Map();
            const dnsTxn = new Map();
            const dnsNxByResponder = new Map();
            const dnsUnansweredByClient = new Map();
            const dhcpByClient = new Map();
            const arpGatewayReq = new Map();
            const icmpHard = new Map();
            const pppoePacketNos = [];

            const ensureIP = (ip) => {
                if (!ip) return null;
                if (!byIP.has(ip)) byIP.set(ip, { sentPkts:0, recvPkts:0, sentBytes:0, recvBytes:0, protocols:new Set(), ports:new Set(), syn:0, synAck:0, rst:0, fin:0, icmpUnreach:0, dnsNx:0, dhcp:{discover:0,request:0,nak:0}, arpReq:0, arpRep:0, exampleNos:[] });
                return byIP.get(ip);
            };
            const ensureMAC = (mac) => {
                if (!mac) return null;
                if (!byMAC.has(mac)) byMAC.set(mac, { sentPkts:0, recvPkts:0, sentBytes:0, recvBytes:0, protocols:new Set(), ports:new Set(), exampleNos:[] });
                return byMAC.get(mac);
            };
            const maxNo = PCAP_FINDING_THRESHOLDS.MAX_PACKET_NOS;
            const maxEx = PCAP_FINDING_THRESHOLDS.MAX_EXAMPLES;

            packets.forEach(packet => {
                const ipLayer = packet.layers?.ip || packet.layers?.ipv6 || null;
                const srcIP = ipLayer?.source || '';
                const dstIP = ipLayer?.destination || '';
                const srcMAC = packet.layers?.ethernet?.source || packet.layers?.sll?.sourceAddress || packet.layers?.arp?.senderMAC || '';
                const dstMAC = packet.layers?.ethernet?.destination || packet.layers?.arp?.targetMAC || '';
                const src = ensureIP(srcIP);
                const dst = ensureIP(dstIP);
                const srcMacRec = ensureMAC(srcMAC);
                const dstMacRec = ensureMAC(dstMAC);
                if (src) { src.sentPkts++; src.sentBytes += packet.length || 0; src.protocols.add(packet.protocol); pushUniqueLimited(src.exampleNos, packet.no, maxNo); }
                if (dst) { dst.recvPkts++; dst.recvBytes += packet.length || 0; dst.protocols.add(packet.protocol); pushUniqueLimited(dst.exampleNos, packet.no, maxNo); }
                if (srcMacRec) { srcMacRec.sentPkts++; srcMacRec.sentBytes += packet.length || 0; srcMacRec.protocols.add(packet.protocol); pushUniqueLimited(srcMacRec.exampleNos, packet.no, maxNo); }
                if (dstMacRec) { dstMacRec.recvPkts++; dstMacRec.recvBytes += packet.length || 0; dstMacRec.protocols.add(packet.protocol); pushUniqueLimited(dstMacRec.exampleNos, packet.no, maxNo); }

                if (packet.protocol === 'PPPoE') pushUniqueLimited(pppoePacketNos, packet.no, maxNo);

                if (packet.layers?.tcp && srcIP && dstIP) {
                    const tcp = packet.layers.tcp;
                    const srcPort = tcp.sourcePort || '';
                    const dstPort = tcp.destinationPort || '';
                    if (src) src.ports.add(srcPort);
                    if (dst) dst.ports.add(dstPort);
                    const key = `${srcIP}:${srcPort}->${dstIP}:${dstPort}`;
                    if (!flows.has(key)) flows.set(key, { syn:0, synAck:0, rst:0, fin:0, lastSynTime:null, dupSyn:0, packetNos:[], srcIP, dstIP, srcPort, dstPort });
                    const flow = flows.get(key);
                    pushUniqueLimited(flow.packetNos, packet.no, maxNo);
                    const flags = tcp.flags || {};
                    if (flags.syn && !flags.ack) {
                        flow.syn++;
                        if (src) src.syn++;
                        const now = packet.absTimestamp || 0;
                        if (flow.lastSynTime !== null && (now - flow.lastSynTime) <= PCAP_FINDING_THRESHOLDS.TCP_DUP_SYN_WINDOW_SEC) flow.dupSyn++;
                        flow.lastSynTime = now;
                    }
                    if (flags.syn && flags.ack) { flow.synAck++; if (src) src.synAck++; }
                    if (flags.rst) { flow.rst++; if (src) src.rst++; }
                    if (flags.fin) { flow.fin++; if (src) src.fin++; }
                }

                if (packet.protocol === 'DNS' && packet.layers?.dns) {
                    const dns = packet.layers.dns;
                    const tx = dns.transactionId || '';
                    const key = `${tx}|${srcIP}|${dstIP}`;
                    const rev = `${tx}|${dstIP}|${srcIP}`;
                    if (dns.isResponse) {
                        const pending = dnsTxn.get(rev);
                        if (pending) { pending.responded = true; pending.responseNo = packet.no; }
                        if (String(dns.responseCode) === '3' || dns.responseCode === 3) {
                            const rkey = srcIP || 'unknown';
                            if (!dnsNxByResponder.has(rkey)) dnsNxByResponder.set(rkey, { count:0, packetNos:[], examples:[], client:dstIP });
                            const rec = dnsNxByResponder.get(rkey);
                            rec.count++;
                            pushUniqueLimited(rec.packetNos, packet.no, maxNo);
                            if (rec.examples.length < maxEx) rec.examples.push({ no: packet.no, summary: summarizePacket(packet) });
                            const clientRec = ensureIP(dstIP);
                            if (clientRec) clientRec.dnsNx++;
                        }
                    } else if (tx) {
                        dnsTxn.set(key, { queryNo: packet.no, queryTime: packet.absTimestamp || 0, responded: false, responseNo: null, client: srcIP, server: dstIP, packet });
                    }
                }

                if (packet.protocol === 'DHCP' && packet.layers?.dhcp) {
                    const type = (packet.layers.dhcp.messageType || '').toLowerCase();
                    const key = srcMAC || srcIP || 'unknown';
                    if (!dhcpByClient.has(key)) dhcpByClient.set(key, { discover:0, request:0, nak:0, packetNos:[], ip:srcIP, mac:srcMAC, examples:[] });
                    const rec = dhcpByClient.get(key);
                    if (type === 'discover') rec.discover++;
                    if (type === 'request') rec.request++;
                    if (type === 'nak') rec.nak++;
                    pushUniqueLimited(rec.packetNos, packet.no, maxNo);
                    if (rec.examples.length < maxEx) rec.examples.push({ no: packet.no, summary: summarizePacket(packet) });
                }

                if (packet.protocol === 'ARP' && packet.layers?.arp) {
                    const arp = packet.layers.arp;
                    if (arp.operation === 'Request') {
                        if (src) src.arpReq++;
                        const t = arp.targetIP || '';
                        if (t.endsWith('.1') || t.endsWith('.254')) {
                            if (!arpGatewayReq.has(t)) arpGatewayReq.set(t, { count:0, packetNos:[], requester: arp.senderIP || srcIP, examples:[] });
                            const rec = arpGatewayReq.get(t);
                            rec.count++;
                            pushUniqueLimited(rec.packetNos, packet.no, maxNo);
                            if (rec.examples.length < maxEx) rec.examples.push({ no: packet.no, summary: summarizePacket(packet) });
                        }
                    }
                    if (arp.operation === 'Reply' && src) src.arpRep++;
                }

                if (packet.protocol === 'ICMP' && packet.layers?.icmp) {
                    const tn = packet.layers.icmp.typeName || '';
                    if (tn === 'Destination Unreachable' || tn === 'Time Exceeded') {
                        const key = `${srcIP}->${dstIP}|${tn}`;
                        if (!icmpHard.has(key)) icmpHard.set(key, { count:0, packetNos:[], examples:[], srcIP, dstIP, type: tn });
                        const rec = icmpHard.get(key);
                        rec.count++;
                        pushUniqueLimited(rec.packetNos, packet.no, maxNo);
                        if (rec.examples.length < maxEx) rec.examples.push({ no: packet.no, summary: summarizePacket(packet) });
                        const srcRec = ensureIP(srcIP);
                        if (srcRec) srcRec.icmpUnreach++;
                    }
                }
            });

            const packetByNo = new Map(packets.map(pkt => [pkt.no, pkt]));
            const createFinding = (finding) => findings.push(finding);
            const timeOf = (no) => {
                const pkt = packetByNo.get(no);
                return pkt ? `${parseFloat(pkt.timestamp || 0).toFixed(6)}s` : 'N/A';
            };

            for (const [ip, rec] of byIP.entries()) {
                const ratio1 = rec.sentPkts / Math.max(rec.recvPkts, 1);
                const ratio2 = rec.recvPkts / Math.max(rec.sentPkts, 1);
                if (ratio1 >= PCAP_FINDING_THRESHOLDS.ONE_WAY_RATIO_THRESHOLD || ratio2 >= PCAP_FINDING_THRESHOLDS.ONE_WAY_RATIO_THRESHOLD) {
                    createFinding({ id: `capture-oneway-${ip}`, category: 'Capture', severity: ratio1 > 100 || ratio2 > 100 ? 'medium' : 'low', title: 'Capture looks one-directional / incomplete', impact: 'Traffic is heavily one-way. This limits ability to confirm ACKs/replies and may hide packet loss or RTT issues.', affected: [{ ip, note: 'traffic imbalance observed' }], evidence: { count: rec.sentPkts + rec.recvPkts, firstSeen: timeOf(rec.exampleNos[0]), lastSeen: timeOf(rec.exampleNos[rec.exampleNos.length - 1]), packetNos: rec.exampleNos.slice(0,maxNo), examples: rec.exampleNos.slice(0,maxEx).map(no => ({ no, summary: summarizePacket(packetByNo.get(no) || {protocol:'N/A',source:'',destination:'',info:''}) })) }, suggestedNextChecks: ['Capture both directions on the same point.', 'Correlate with interface counters for drops.'], actions: { filterText: ip, protocol: '', jumpToPacketNo: rec.exampleNos[0] } });
                }
            }

            for (const flow of flows.values()) {
                const revKey = `${flow.dstIP}:${flow.dstPort}->${flow.srcIP}:${flow.srcPort}`;
                const rev = flows.get(revKey);
                const synAck = (rev ? rev.synAck : 0) + flow.synAck;
                if (flow.syn >= PCAP_FINDING_THRESHOLDS.TCP_FAILED_HANDSHAKE_SYN && synAck === 0) {
                    createFinding({ id:`tcp-handshake-${flow.srcIP}-${flow.srcPort}-${flow.dstIP}-${flow.dstPort}`, category:'TCP', severity:'high', title:'Connection attempts not completing', impact:'Clients may experience connection timeouts or app sessions that never establish.', affected:[{ ip:flow.srcIP, port:flow.srcPort, note:'client' },{ ip:flow.dstIP, port:flow.dstPort, note:'server' }], evidence:{ count:flow.syn, firstSeen:timeOf(flow.packetNos[0]), lastSeen:timeOf(flow.packetNos[flow.packetNos.length-1]), packetNos:flow.packetNos.slice(0,maxNo), examples:flow.packetNos.slice(0,maxEx).map(no=>({no, summary:summarizePacket(packetByNo.get(no) || { protocol: 'N/A', source: '', destination: '', info: '' })})) }, suggestedNextChecks:['Check server reachability and firewall policies.','Verify SYN/ACK return path.'], actions:{ filterText:`${flow.dstIP} SYN`, protocol:'TCP', jumpToPacketNo:flow.packetNos[0] } });
                }
                if (flow.rst >= PCAP_FINDING_THRESHOLDS.TCP_RST_THRESHOLD) {
                    createFinding({ id:`tcp-rst-${flow.srcIP}-${flow.dstIP}-${flow.srcPort}-${flow.dstPort}`, category:'TCP', severity:'high', title:'Excessive TCP resets detected', impact:'Active sessions may abruptly disconnect and force reconnects.', affected:[{ ip:flow.srcIP, port:flow.srcPort },{ ip:flow.dstIP, port:flow.dstPort }], evidence:{ count:flow.rst, firstSeen:timeOf(flow.packetNos[0]), lastSeen:timeOf(flow.packetNos[flow.packetNos.length-1]), packetNos:flow.packetNos.slice(0,maxNo), examples:flow.packetNos.slice(0,maxEx).map(no=>({no, summary:summarizePacket(packetByNo.get(no) || { protocol: 'N/A', source: '', destination: '', info: '' })})) }, suggestedNextChecks:['Inspect application/server reset reasons.','Check middlebox timeout/reject policies.'], actions:{ filterText:`${flow.srcIP} RST`, protocol:'TCP', jumpToPacketNo:flow.packetNos[0] } });
                }
            }

            for (const [resolver, rec] of dnsNxByResponder.entries()) {
                if (rec.count >= PCAP_FINDING_THRESHOLDS.DNS_NXDOMAIN_THRESHOLD) {
                    createFinding({ id:`dns-nxdomain-${resolver}`, category:'DNS', severity:'medium', title:'High NXDOMAIN rate', impact:'Users may see slow page/app loads or failed hostname lookups.', affected:[{ ip:resolver, note:'DNS responder' },{ ip:rec.client, note:'client(s)' }], evidence:{ count:rec.count, firstSeen:timeOf(rec.packetNos[0]), lastSeen:timeOf(rec.packetNos[rec.packetNos.length-1]), packetNos:rec.packetNos, examples:rec.examples }, suggestedNextChecks:['Review queried domains for typos/misconfigurations.','Check resolver forwarder health.'], actions:{ filterText:resolver || 'DNS', protocol:'DNS', jumpToPacketNo:rec.packetNos[0] } });
                }
            }

            for (const tx of dnsTxn.values()) {
                if (!tx.responded) {
                    const key = tx.client || 'unknown-client';
                    if (!dnsUnansweredByClient.has(key)) dnsUnansweredByClient.set(key, { count:0, packetNos:[], examples:[], server: tx.server });
                    const rec = dnsUnansweredByClient.get(key);
                    rec.count++;
                    pushUniqueLimited(rec.packetNos, tx.queryNo, maxNo);
                    if (rec.examples.length < maxEx) rec.examples.push({ no: tx.queryNo, summary: summarizePacket(tx.packet) });
                }
            }
            for (const [client, rec] of dnsUnansweredByClient.entries()) {
                if (rec.count >= PCAP_FINDING_THRESHOLDS.DNS_UNANSWERED_THRESHOLD) {
                    createFinding({ id:`dns-unanswered-${client}`, category:'DNS', severity:'high', title:'Many DNS queries with no responses', impact:'Name resolution delays can cause broad browsing/app timeouts.', affected:[{ ip:client, note:'query source' }, { ip:rec.server, note:'DNS server' }], evidence:{ count:rec.count, firstSeen:timeOf(rec.packetNos[0]), lastSeen:timeOf(rec.packetNos[rec.packetNos.length-1]), packetNos:rec.packetNos, examples:rec.examples }, suggestedNextChecks:['Check DNS server reachability.','Verify ACLs and UDP/53 path.'], actions:{ filterText:client, protocol:'DNS', jumpToPacketNo:rec.packetNos[0] } });
                }
            }

            for (const rec of dhcpByClient.values()) {
                const churn = rec.discover + rec.request;
                if (churn >= PCAP_FINDING_THRESHOLDS.DHCP_BURST_THRESHOLD || rec.nak > 0) {
                    createFinding({ id:`dhcp-churn-${rec.mac || rec.ip}`, category:'DHCP', severity:rec.nak > 0 ? 'high' : 'medium', title:'Repeated DHCP requests (possible lease instability)', impact:'Devices may briefly lose connectivity while repeatedly renewing or requesting leases.', affected:[{ ip:rec.ip, mac:rec.mac, note:'client' }], evidence:{ count:churn + rec.nak, firstSeen:timeOf(rec.packetNos[0]), lastSeen:timeOf(rec.packetNos[rec.packetNos.length-1]), packetNos:rec.packetNos, examples:rec.examples }, suggestedNextChecks:['Check DHCP scope utilization and lease time.','Inspect AP/client reconnect behavior.'], actions:{ filterText:`DHCP ${rec.ip || rec.mac || ''}`.trim(), protocol:'DHCP', jumpToPacketNo:rec.packetNos[0] } });
                }
            }

            rogueDevices.forEach((device, idx) => {
                const matchNos = packets.filter(p => (device.ip && `${p.source} ${p.destination}`.includes(device.ip)) || (device.mac && `${p.source} ${p.destination}`.includes(device.mac))).slice(0,maxNo).map(p => p.no);
                createFinding({ id:`security-rogue-${idx}-${device.type}`, category:'Security', severity:device.severity === 'critical' ? 'high' : 'medium', title:device.description, impact:'Potential rogue infrastructure can redirect or intercept user traffic.', affected:[{ ip:device.ip, mac:device.mac, note:device.type }], evidence:{ count:matchNos.length, firstSeen:timeOf(matchNos[0]), lastSeen:timeOf(matchNos[matchNos.length-1]), packetNos:matchNos, examples:matchNos.slice(0,maxEx).map(no=>({no, summary:summarizePacket(packetByNo.get(no) || { protocol: 'N/A', source: '', destination: '', info: '' })})) }, suggestedNextChecks:['Validate device ownership and isolate suspicious endpoint.'], actions:{ filterText:device.ip || device.mac || 'ARP', protocol: device.type === 'dns' ? 'DNS' : 'ARP', jumpToPacketNo:matchNos[0] } });
            });

            for (const [gateway, rec] of arpGatewayReq.entries()) {
                if (rec.count >= PCAP_FINDING_THRESHOLDS.ARP_GATEWAY_REQUEST_THRESHOLD) {
                    createFinding({ id:`arp-gateway-${gateway}`, category:'ARP', severity:'medium', title:'Gateway ARP request burst', impact:'Frequent ARP resolution attempts may indicate gateway instability or L2 disruption.', affected:[{ ip:gateway, note:'gateway target' },{ ip:rec.requester, note:'requester' }], evidence:{ count:rec.count, firstSeen:timeOf(rec.packetNos[0]), lastSeen:timeOf(rec.packetNos[rec.packetNos.length-1]), packetNos:rec.packetNos, examples:rec.examples }, suggestedNextChecks:['Check gateway CPU/interface health.','Inspect LAN for ARP storms/spoofing.'], actions:{ filterText:gateway, protocol:'ARP', jumpToPacketNo:rec.packetNos[0] } });
                }
            }

            if (stats?.pppoe) {
                const pp = stats.pppoe;
                if (pp.padi >= PCAP_FINDING_THRESHOLDS.PPPOE_PADI_THRESHOLD && pp.pads === 0) {
                    createFinding({ id:'pppoe-padi-no-pads', category:'PPPoE', severity:'high', title:'PPPoE discovery failing (PADI with no PADS)', impact:'Customers can lose internet access when PPPoE discovery cannot complete.', affected:[{ note:'WAN PPPoE session' }], evidence:{ count:pp.padi, firstSeen:timeOf(pppoePacketNos[0]), lastSeen:timeOf(pppoePacketNos[pppoePacketNos.length-1]), packetNos:pppoePacketNos.slice(0,maxNo), examples:pppoePacketNos.slice(0,maxEx).map(no=>({no, summary:summarizePacket(packetByNo.get(no) || { protocol: 'N/A', source: '', destination: '', info: '' })})) }, suggestedNextChecks:['Verify ISP PPPoE credentials and BRAS reachability.'], actions:{ filterText:'PPPoE PADI', protocol:'PPPoE', jumpToPacketNo:pppoePacketNos[0] } });
                }
                if (pp.padt >= PCAP_FINDING_THRESHOLDS.PPPOE_PADT_THRESHOLD) {
                    createFinding({ id:'pppoe-padt-seen', category:'PPPoE', severity:pp.padt > 3 ? 'high' : 'medium', title:'PPPoE session terminated (PADT seen)', impact:'Session terminations can cause brief to prolonged internet interruptions.', affected:[{ note:'WAN PPPoE session' }], evidence:{ count:pp.padt, firstSeen:timeOf(pppoePacketNos[0]), lastSeen:timeOf(pppoePacketNos[pppoePacketNos.length-1]), packetNos:pppoePacketNos.slice(0,maxNo), examples:pppoePacketNos.slice(0,maxEx).map(no=>({no, summary:summarizePacket(packetByNo.get(no) || { protocol: 'N/A', source: '', destination: '', info: '' })})) }, suggestedNextChecks:['Correlate PADT timing with line-quality or authentication events.'], actions:{ filterText:'PPPoE PADT', protocol:'PPPoE', jumpToPacketNo:pppoePacketNos[0] } });
                }
                const discoveryTotal = pp.padi + pp.pado + pp.padr + pp.pads;
                if (discoveryTotal >= (PCAP_FINDING_THRESHOLDS.PPPOE_PADI_THRESHOLD * 3)) {
                    createFinding({ id:'pppoe-reconnect-loop', category:'PPPoE', severity:'medium', title:'PPPoE reconnect loop indicators', impact:'Repeated PPPoE discovery can appear as intermittent disconnect/reconnect behavior.', affected:[{ note:'WAN PPPoE session' }], evidence:{ count:discoveryTotal, firstSeen:timeOf(pppoePacketNos[0]), lastSeen:timeOf(pppoePacketNos[pppoePacketNos.length-1]), packetNos:pppoePacketNos.slice(0,maxNo), examples:pppoePacketNos.slice(0,maxEx).map(no=>({no, summary:summarizePacket(packetByNo.get(no) || { protocol: 'N/A', source: '', destination: '', info: '' })})) }, suggestedNextChecks:['Check PPPoE keepalive and upstream stability.'], actions:{ filterText:'PPPoE', protocol:'PPPoE', jumpToPacketNo:pppoePacketNos[0] } });
                }
            }

            for (const [k, rec] of icmpHard.entries()) {
                if (rec.count >= 3) {
                    createFinding({ id:`icmp-hard-${k}`, category:'Capture', severity:rec.count > 10 ? 'high' : 'medium', title:`ICMP hard signal: ${rec.type}`, impact:'Routing/MTU/TTL issues may cause traffic blackholes or inconsistent latency.', affected:[{ ip:rec.srcIP, note:'icmp source' },{ ip:rec.dstIP, note:'icmp target' }], evidence:{ count:rec.count, firstSeen:timeOf(rec.packetNos[0]), lastSeen:timeOf(rec.packetNos[rec.packetNos.length-1]), packetNos:rec.packetNos, examples:rec.examples }, suggestedNextChecks:['Trace route path and verify MTU.'], actions:{ filterText:`ICMP ${rec.dstIP}`.trim(), protocol:'ICMP', jumpToPacketNo:rec.packetNos[0] } });
                }
            }

            findings.sort((a,b) => ({high:3, medium:2, low:1}[b.severity] - ({high:3, medium:2, low:1}[a.severity])) || ((b.evidence?.count||0)-(a.evidence?.count||0)));
            const summary = findings.reduce((acc,f)=>{acc.total++;acc[f.severity]=(acc[f.severity]||0)+1;return acc;},{total:0,high:0,medium:0,low:0});
            return { findings, summary };
        }

        function applyPCAPFilters() {
            const filterText = document.getElementById('packetFilter').value.toLowerCase().trim();
            const protocolFilter = document.getElementById('protocolFilter').value;

            filteredPackets = allPackets.filter(packet => {
                // Protocol filter
                if (protocolFilter && packet.protocol !== protocolFilter) {
                    return false;
                }

                // Text filter
                if (filterText) {
                    const searchIn = `${packet.protocol} ${packet.source} ${packet.destination} ${packet.info}`.toLowerCase();
                    return searchIn.includes(filterText);
                }

                return true;
            });

            renderPacketTable();
        }

        function clearPCAPFilters() {
            document.getElementById('packetFilter').value = '';
            document.getElementById('protocolFilter').value = '';
            filteredPackets = allPackets;
            renderPacketTable();
        }

        // TCP Stream Functions
        function followTCPStream(packetNo) {
            const packet = allPackets.find(p => p.no === packetNo);
            if (!packet || !packet.layers?.tcp) {
                alert('This packet does not contain TCP data');
                return;
            }

            const tcp = packet.layers.tcp;
            const ip = packet.layers.ip;
            
            if (!ip) {
                alert('Could not determine IP addresses for this stream');
                return;
            }

            const streamKey = createStreamKey(ip.source, tcp.sourcePort, ip.destination, tcp.destinationPort);
            
            // Build or retrieve stream
            let stream = tcpStreams.get(streamKey);
            if (!stream) {
                stream = buildTCPStream(streamKey);
                tcpStreams.set(streamKey, stream);
            }

            displayTCPStream(stream);
        }

        function createStreamKey(srcIP, srcPort, dstIP, dstPort) {
            // Normalize stream key so both directions map to same stream
            const addr1 = `${srcIP}:${srcPort}`;
            const addr2 = `${dstIP}:${dstPort}`;
            return addr1 < addr2 ? `${addr1}-${addr2}` : `${addr2}-${addr1}`;
        }

        function buildTCPStream(streamKey) {
            const [addr1, addr2] = streamKey.split('-');
            const [ip1, port1] = addr1.split(':');
            const [ip2, port2] = addr2.split(':');

            const stream = {
                key: streamKey,
                client: addr1,
                server: addr2,
                packets: [],
                segments: [],
                totalBytes: 0,
                isHTTP: false,
                isHTTPS: false
            };

            // Find all packets belonging to this stream
            allPackets.forEach(packet => {
                if (!packet.layers?.tcp || !packet.layers?.ip) return;

                const pktSrc = packet.layers.ip.source;
                const pktDst = packet.layers.ip.destination;
                const pktSrcPort = packet.layers.tcp.sourcePort;
                const pktDstPort = packet.layers.tcp.destinationPort;

                const pktAddr1 = `${pktSrc}:${pktSrcPort}`;
                const pktAddr2 = `${pktDst}:${pktDstPort}`;

                if ((pktAddr1 === addr1 && pktAddr2 === addr2) || (pktAddr1 === addr2 && pktAddr2 === addr1)) {
                    stream.packets.push(packet);
                    
                    // Check for HTTP/HTTPS
                    if (pktSrcPort === 80 || pktDstPort === 80 || pktSrcPort === 8080 || pktDstPort === 8080) {
                        stream.isHTTP = true;
                    }
                    if (pktSrcPort === 443 || pktDstPort === 443) {
                        stream.isHTTPS = true;
                    }

                    // Extract payload if available
                    if (packet.rawData && packet.rawData.byteLength > 0) {
                        const direction = pktAddr1 === addr1 ? 'C‚ÜíS' : 'S‚ÜíC';
                        const seqNum = packet.layers.tcp.sequenceNumber || 0;
                        
                        stream.segments.push({
                            seqNum: parseInt(seqNum),
                            direction,
                            data: packet.rawData,
                            packetNo: packet.no
                        });
                        
                        stream.totalBytes += packet.rawData.byteLength;
                    }
                }
            });

            // Sort segments by sequence number
            stream.segments.sort((a, b) => a.seqNum - b.seqNum);

            return stream;
        }

        function displayTCPStream(stream) {
            const modal = document.getElementById('tcpStreamModal');
            const streamInfo = document.getElementById('streamInfo');
            const streamData = document.getElementById('streamData');

            // Build header info
            let info = `
                <div><strong>Stream:</strong> <span>${stream.client}</span> ‚Üî <span>${stream.server}</span></div>
                <div><strong>Packets:</strong> <span>${stream.packets.length}</span></div>
                <div><strong>Total Bytes:</strong> <span>${stream.totalBytes.toLocaleString()}</span></div>
            `;

            if (stream.isHTTP) {
                info += `<div><strong>Protocol:</strong> <span style="color: var(--green);">HTTP</span></div>`;
            } else if (stream.isHTTPS) {
                info += `<div><strong>Protocol:</strong> <span style="color: var(--proto-https);">HTTPS (Encrypted)</span></div>`;
            } else {
                info += `<div><strong>Protocol:</strong> <span>TCP</span></div>`;
            }

            streamInfo.innerHTML = info;

            // Build stream data view
            let dataView = '';

            if (stream.isHTTPS) {
                dataView = `üîí This is an HTTPS (encrypted) connection\n\nThe payload data is encrypted and cannot be decoded without the session keys.\nTLS/SSL handshake occurred on port 443.\n\nStream contains ${stream.packets.length} encrypted packets totaling ${stream.totalBytes.toLocaleString()} bytes.`;
            } else if (stream.isHTTP) {
                // Try to decode as HTTP
                dataView = decodeHTTPStream(stream);
            } else {
                // Show raw hex dump
                dataView = 'TCP Stream Data (Hex):\n\n';
                stream.segments.forEach(seg => {
                    dataView += `\n[${seg.direction}] Packet ${seg.packetNo} (Seq: ${seg.seqNum}):\n`;
                    dataView += generateHexDump(seg.data, seg.data.byteLength) + '\n';
                });
            }

            streamData.textContent = dataView;
            modal.classList.add('show');

            // Store current stream for export
            window.currentStream = stream;
        }

        function decodeHTTPStream(stream) {
            let decoded = '';
            
            stream.segments.forEach(seg => {
                const bytes = new Uint8Array(seg.data);
                let text = '';
                
                // Try to decode as ASCII/UTF-8
                for (let i = 0; i < Math.min(bytes.length, 1500); i++) {
                    const byte = bytes[i];
                    if (byte >= 32 && byte < 127) {
                        text += String.fromCharCode(byte);
                    } else if (byte === 10) {
                        text += '\n';
                    } else if (byte === 13) {
                        // Skip CR
                    } else {
                        text += '.';
                    }
                }

                if (text.includes('HTTP/') || text.includes('GET ') || text.includes('POST ') || text.includes('Content-')) {
                    decoded += `\n========== [${seg.direction}] Packet ${seg.packetNo} ==========\n`;
                    decoded += text + '\n';
                }
            });

            return decoded || 'No readable HTTP data found in stream';
        }

        function closeStreamModal() {
            document.getElementById('tcpStreamModal').classList.remove('show');
        }

        function exportTCPStream() {
            if (!window.currentStream) return;

            const stream = window.currentStream;
            let content = `TCP Stream Export\n`;
            content += `Stream: ${stream.client} <-> ${stream.server}\n`;
            content += `Packets: ${stream.packets.length}\n`;
            content += `Total Bytes: ${stream.totalBytes}\n`;
            content += `Protocol: ${stream.isHTTP ? 'HTTP' : stream.isHTTPS ? 'HTTPS' : 'TCP'}\n`;
            content += `\n${'='.repeat(80)}\n\n`;

            if (stream.isHTTPS) {
                content += 'ENCRYPTED HTTPS DATA (cannot decode without session keys)\n';
            } else if (stream.isHTTP) {
                content += decodeHTTPStream(stream);
            } else {
                stream.segments.forEach(seg => {
                    content += `\n[${seg.direction}] Packet ${seg.packetNo}:\n`;
                    content += generateHexDump(seg.data, seg.data.byteLength) + '\n';
                });
            }

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tcp_stream_${stream.key.replace(/[:.]/g, '_')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function toggleHexDump(packetNo) {
            hexDumpExpanded = !hexDumpExpanded;
            const packet = allPackets.find(p => p.no === packetNo);
            if (packet) {
                displayPacketDetails(packet);
            }
        }

        function truncate(str, length) {
            if (!str) return '';
            return str.length > length ? str.substring(0, length) + '...' : str;
        }

        // ============================================
        // EVENT LOG PARSING
        // ============================================

        async function analyzeEventLog(text, filename) {
            console.time('Event Log Parsing');
            updateProgress(5, 'Parsing event log...');

            allEvents = [];
            const lines = text.split('\n');
            
            // Remove BOM if present
            if (lines.length > 0 && lines[0].charCodeAt(0) === 0xFEFF) {
                lines[0] = lines[0].substring(1);
            }
            
            // Detect format
            const firstLine = lines[0].trim();
            let format = 'unknown';
            
            if (firstLine.includes('\t') && firstLine.includes('Date')) {
                format = 'tab';
            } else if (firstLine.includes('Date') && firstLine.includes('Time') && firstLine.includes('Details')) {
                format = 'csv';
            }

            console.log(`Detected format: ${format}`);

            if (format === 'csv') {
                // Parse CSV format
                for (let i = 1; i < lines.length; i++) {
                    if (i % 100 === 0) {
                        updateProgress(5 + (i / lines.length) * 90, `Processing line ${i}/${lines.length}...`);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }

                    const line = lines[i].trim();
                    if (!line) continue;

                    const event = parseCSVEvent(line, i);
                    if (event) allEvents.push(event);
                }
            } else if (format === 'tab') {
                // Parse tab-delimited format
                for (let i = 1; i < lines.length; i++) {
                    if (i % 100 === 0) {
                        updateProgress(5 + (i / lines.length) * 90, `Processing line ${i}/${lines.length}...`);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }

                    const line = lines[i].trim();
                    if (!line) continue;

                    const event = parseTabEvent(line, i);
                    if (event) allEvents.push(event);
                }
            }

            updateProgress(95, 'Analyzing patterns...');

            const eventStats = analyzeEventPatterns(allEvents, filename);

            updateProgress(100, `Complete! Loaded ${allEvents.length.toLocaleString()} events`);
            console.timeEnd('Event Log Parsing');

            displayEventLogViewer(eventStats);
            setTimeout(() => showProgress(false), 500);
        }

        function parseCSVEvent(line, lineNum) {
            const fields = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    fields.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            fields.push(current.trim());

            if (fields.length < 4) return null;

            return {
                no: lineNum,
                date: fields[0],
                time: fields[1],
                details: fields[2] || '',
                category: fields[3] || 'Unknown',
                severity: fields[4] || 'Info',
                raw: line
            };
        }

        function parseTabEvent(line, lineNum) {
            const fields = line.split('\t').map(f => f.trim()).filter(f => f.length > 0);
            
            if (fields.length < 5) return null;

            return {
                no: lineNum,
                date: fields[0],
                time: fields[1],
                category: fields[2] || 'Unknown',
                severity: fields[3] || 'Info',
                details: fields[4] || '',
                raw: line
            };
        }

        function parseEventTimestamp(dateStr, timeStr) {
            if (!dateStr || !timeStr) return null;
            const cleanedTime = (timeStr || '').split(' ')[0].replace(',', '.');
            const [hh = '0', mm = '0', ssPart = '0'] = cleanedTime.split(':');
            const [ssRaw = '0', msRaw = '0'] = ssPart.split('.');
            const second = parseInt(ssRaw, 10) || 0;
            const ms = parseInt((msRaw + '000').slice(0, 3), 10) || 0;

            const dmy = dateStr.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/);
            if (dmy) {
                const day = parseInt(dmy[1], 10);
                const month = parseInt(dmy[2], 10) - 1;
                const year = parseInt(dmy[3], 10);
                return new Date(year, month, day, parseInt(hh, 10) || 0, parseInt(mm, 10) || 0, second, ms).getTime();
            }

            const ymd = dateStr.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
            if (ymd) {
                const year = parseInt(ymd[1], 10);
                const month = parseInt(ymd[2], 10) - 1;
                const day = parseInt(ymd[3], 10);
                return new Date(year, month, day, parseInt(hh, 10) || 0, parseInt(mm, 10) || 0, second, ms).getTime();
            }

            const fallback = new Date(`${dateStr} ${cleanedTime}`);
            return Number.isNaN(fallback.getTime()) ? null : fallback.getTime();
        }

        function pushSample(list, event, max = 5) {
            if (list.length < max) {
                list.push({ no: event.no, details: truncate(event.details, 140) });
            }
        }

        function analyzeEventPatterns(events, filename) {
            const DETECTION_THRESHOLDS = {
                WIFI_FLAP_THRESHOLD: 20,
                WIFI_RAPID_SWITCH_SECONDS: 10,
                DHCP_NOISE_THRESHOLD: 30,
                ETH_LINK_FLAP_THRESHOLD: 1,
                ETH_LOW_SPEEDS: [10, 100],
                PPPOE_FAIL_THRESHOLD: 1,
                MAX_FINDING_EXAMPLES: 5
            };

            const patterns = {
                filename: filename,
                totalEvents: events.length,
                timeRange: { first: null, last: null },
                categories: {},
                severities: {},
                macAddresses: new Set(),
                wifiEvents: { deauth: [], disassoc: [], assoc: [], auth: [] },
                pppoeEvents: { padi: [], connectionFailures: [] },
                findings: []
            };

            const macRegex = /([0-9a-fA-F]{2}(?::[0-9a-fA-F]{2}){5})/g;
            const ipv4Regex = /\b(?:\d{1,3}\.){3}\d{1,3}\b/g;
            const wifiRegex = /(\S+):\s+AP-STA-(CONNECTED|DISCONNECTED)\s+([0-9a-f:]{17})/i;
            const dhcpReqRegex = /DHCPREQUEST\([^)]+\)\s+(\d+\.\d+\.\d+\.\d+)\s+([0-9a-f:]{17})/i;
            const dhcpAckRegex = /DHCPACK\([^)]+\)\s+(\d+\.\d+\.\d+\.\d+)\s+([0-9a-f:]{17})\s*(\S+)?/i;
            const ethLinkRegex = /^(eth\d+).*Link (DOWN|Up)/i;
            const ethSpeedRegex = /Link Up at\s+(\d+)\s+mbps/i;

            const macIndex = new Map();
            const ipIndex = new Map();
            const ifaceIndex = new Map();
            const rapidSwitchByMac = new Map();
            const pppoeSummary = { signals: 0, failures: 0, reconnectLoops: 0, samples: [] };

            function ensureMac(mac) {
                const key = (mac || '').toUpperCase();
                if (!key) return null;
                if (!macIndex.has(key)) {
                    macIndex.set(key, {
                        mac: key,
                        ips: new Set(),
                        hostnames: new Set(),
                        wifi: { connected: 0, disconnected: 0, deauth: 0, disassoc: 0, handshake: 0, interfaces: new Set(), lastState: null, samples: [] },
                        dhcp: { request: 0, ack: 0, samples: [] },
                        pppoe: { events: 0, failures: 0 },
                        severityEvents: [],
                        samples: []
                    });
                }
                return macIndex.get(key);
            }

            function ensureIp(ip) {
                if (!ip) return null;
                if (!ipIndex.has(ip)) {
                    ipIndex.set(ip, { ip, macs: new Set(), hostnames: new Set(), dhcpRequest: 0, dhcpAck: 0, samples: [] });
                }
                return ipIndex.get(ip);
            }

            events.forEach((event, idx) => {
                if (idx === 0) patterns.timeRange.first = `${event.date} ${event.time}`;
                if (idx === events.length - 1) patterns.timeRange.last = `${event.date} ${event.time}`;

                const details = event.details || '';
                const lower = details.toLowerCase();
                const eventTs = parseEventTimestamp(event.date, event.time);
                patterns.categories[event.category] = (patterns.categories[event.category] || 0) + 1;
                patterns.severities[event.severity] = (patterns.severities[event.severity] || 0) + 1;

                const macs = (details.match(macRegex) || []).map(m => m.toUpperCase());
                const ips = details.match(ipv4Regex) || [];

                macs.forEach(mac => {
                    patterns.macAddresses.add(mac);
                    const rec = ensureMac(mac);
                    pushSample(rec.samples, event, DETECTION_THRESHOLDS.MAX_FINDING_EXAMPLES);
                });

                ips.forEach(ip => {
                    const ipRec = ensureIp(ip);
                    pushSample(ipRec.samples, event, DETECTION_THRESHOLDS.MAX_FINDING_EXAMPLES);
                    macs.forEach(mac => ipRec.macs.add(mac));
                });

                if (event.details.includes('DEAUTH')) patterns.wifiEvents.deauth.push({ time: event.time, details: event.details });
                if (event.details.includes('DISASSOC')) patterns.wifiEvents.disassoc.push({ time: event.time, details: event.details });

                const wifiMatch = details.match(wifiRegex);
                if (wifiMatch) {
                    const iface = wifiMatch[1];
                    const state = wifiMatch[2].toUpperCase();
                    const mac = wifiMatch[3].toUpperCase();
                    const rec = ensureMac(mac);
                    rec.wifi.interfaces.add(iface);
                    if (state === 'CONNECTED') rec.wifi.connected += 1;
                    if (state === 'DISCONNECTED') rec.wifi.disconnected += 1;
                    pushSample(rec.wifi.samples, event, DETECTION_THRESHOLDS.MAX_FINDING_EXAMPLES);

                    if (rec.wifi.lastState && rec.wifi.lastState.iface !== iface && rec.wifi.lastState.ts !== null && eventTs !== null) {
                        const deltaSec = Math.abs(eventTs - rec.wifi.lastState.ts) / 1000;
                        const prevState = rec.wifi.lastState.state;
                        if (deltaSec <= DETECTION_THRESHOLDS.WIFI_RAPID_SWITCH_SECONDS && ((prevState === 'DISCONNECTED' && state === 'CONNECTED') || (prevState === 'CONNECTED' && state === 'DISCONNECTED'))) {
                            const rapid = rapidSwitchByMac.get(mac) || { count: 0, interfaces: new Set(), samples: [] };
                            rapid.count += 1;
                            rapid.interfaces.add(rec.wifi.lastState.iface);
                            rapid.interfaces.add(iface);
                            pushSample(rapid.samples, event, DETECTION_THRESHOLDS.MAX_FINDING_EXAMPLES);
                            rapidSwitchByMac.set(mac, rapid);
                        }
                    }
                    rec.wifi.lastState = { state, iface, ts: eventTs };
                }

                if (lower.includes('wpa: pairwise key handshake completed')) {
                    if (macs.length > 0) macs.forEach(mac => ensureMac(mac).wifi.handshake += 1);
                }

                const reqMatch = details.match(dhcpReqRegex);
                if (reqMatch) {
                    const ip = reqMatch[1];
                    const mac = reqMatch[2].toUpperCase();
                    const rec = ensureMac(mac);
                    rec.dhcp.request += 1;
                    rec.ips.add(ip);
                    pushSample(rec.dhcp.samples, event, DETECTION_THRESHOLDS.MAX_FINDING_EXAMPLES);

                    const ipRec = ensureIp(ip);
                    ipRec.dhcpRequest += 1;
                    ipRec.macs.add(mac);
                }

                const ackMatch = details.match(dhcpAckRegex);
                if (ackMatch) {
                    const ip = ackMatch[1];
                    const mac = ackMatch[2].toUpperCase();
                    const hostname = ackMatch[3] || '';
                    const rec = ensureMac(mac);
                    rec.dhcp.ack += 1;
                    rec.ips.add(ip);
                    if (hostname) rec.hostnames.add(hostname);
                    pushSample(rec.dhcp.samples, event, DETECTION_THRESHOLDS.MAX_FINDING_EXAMPLES);

                    const ipRec = ensureIp(ip);
                    ipRec.dhcpAck += 1;
                    ipRec.macs.add(mac);
                    if (hostname) ipRec.hostnames.add(hostname);
                }

                const ethMatch = details.match(ethLinkRegex);
                if (ethMatch) {
                    const iface = ethMatch[1].toLowerCase();
                    const state = ethMatch[2].toLowerCase();
                    if (!ifaceIndex.has(iface)) ifaceIndex.set(iface, { interfaceName: iface, linkDownCount: 0, linkUpCount: 0, speeds: [], samples: [] });
                    const ifaceRec = ifaceIndex.get(iface);
                    if (state === 'down') ifaceRec.linkDownCount += 1;
                    if (state === 'up') ifaceRec.linkUpCount += 1;
                    const speedMatch = details.match(ethSpeedRegex);
                    if (speedMatch) ifaceRec.speeds.push(parseInt(speedMatch[1], 10));
                    pushSample(ifaceRec.samples, event, DETECTION_THRESHOLDS.MAX_FINDING_EXAMPLES);
                }

                const isFirewallDrop = lower.includes('drop') && lower.includes('in=pppoe-wan');
                const pppoeSignal = /\bPADI\b|\bPADO\b|\bPADR\b|\bPADS\b|\bPADT\b/i.test(details) || (lower.includes('pppoe-wan') && lower.includes('session'));
                const pppoeFailure = (/\bLCP\b/i.test(details) && /(down|terminated|timeout)/i.test(details)) || (/\b(CHAP|PAP)\b/i.test(details) && /(failed|failure)/i.test(details)) || (lower.includes('pppoe-wan') && /(disconnected|reconnect|link down)/i.test(details)) || /\bPADT\b/i.test(details);

                if (pppoeSignal && !isFirewallDrop) {
                    pppoeSummary.signals += 1;
                    pushSample(pppoeSummary.samples, event, DETECTION_THRESHOLDS.MAX_FINDING_EXAMPLES);
                }
                if (pppoeFailure && !isFirewallDrop) {
                    pppoeSummary.failures += 1;
                    if (lower.includes('reconnect')) pppoeSummary.reconnectLoops += 1;
                }

                const severity = (event.severity || '').toLowerCase();
                const isHighSeverity = severity.includes('critical') || severity.includes('error');
                if (isHighSeverity) {
                    if (macs.length > 0) macs.forEach(mac => ensureMac(mac).severityEvents.push(event));
                    if (ips.length > 0) ips.forEach(ip => ensureIp(ip));
                }
            });

            patterns.macAddresses = Array.from(patterns.macAddresses);

            function createFinding(finding) { patterns.findings.push(finding); }

            for (const rec of macIndex.values()) {
                const totalWifiEvents = rec.wifi.connected + rec.wifi.disconnected;
                if (totalWifiEvents >= DETECTION_THRESHOLDS.WIFI_FLAP_THRESHOLD * 2 || rec.wifi.disconnected >= DETECTION_THRESHOLDS.WIFI_FLAP_THRESHOLD) {
                    createFinding({ id: `wifi-flap-${rec.mac}`, title: 'Wi-Fi client is repeatedly disconnecting/reconnecting', severity: rec.wifi.disconnected > DETECTION_THRESHOLDS.WIFI_FLAP_THRESHOLD * 2 ? 'high' : 'medium', category: 'WiFi',
                        affected: [{ mac: rec.mac, ip: Array.from(rec.ips)[0] || '', hostname: Array.from(rec.hostnames)[0] || '', iface: Array.from(rec.wifi.interfaces).join('/') }],
                        impact: 'Intermittent Wi-Fi: brief drops, unstable calls, and app session resets are likely.',
                        evidence: { count: totalWifiEvents, firstSeen: patterns.timeRange.first, lastSeen: patterns.timeRange.last, examples: rec.wifi.samples },
                        suggestedNextChecks: ['Check band-steering / smart-connect thresholds.', 'Review client RSSI and roam aggressiveness.', 'Verify mesh/extender backhaul stability.'],
                        filterKeys: { mac: [rec.mac], ip: Array.from(rec.ips), keywords: ['AP-STA', 'DISCONNECTED', 'CONNECTED'], iface: Array.from(rec.wifi.interfaces) } });
                }
                const dhcpTotal = rec.dhcp.request + rec.dhcp.ack;
                if (dhcpTotal >= DETECTION_THRESHOLDS.DHCP_NOISE_THRESHOLD) {
                    createFinding({ id: `dhcp-noise-${rec.mac}`, title: 'DHCP churn/noise detected for client', severity: dhcpTotal > DETECTION_THRESHOLDS.DHCP_NOISE_THRESHOLD * 2 ? 'high' : 'medium', category: 'DHCP',
                        affected: [{ mac: rec.mac, ip: Array.from(rec.ips)[0] || '', hostname: Array.from(rec.hostnames)[0] || '' }],
                        impact: 'Frequent lease renewals can indicate unstable connectivity or repeated network reattachment.',
                        evidence: { count: dhcpTotal, firstSeen: patterns.timeRange.first, lastSeen: patterns.timeRange.last, examples: rec.dhcp.samples },
                        suggestedNextChecks: ['Check DHCP lease duration and scope utilization.', 'Verify client is not power-cycling Wi-Fi frequently.', 'Inspect AP logs for disconnect reason codes.'],
                        filterKeys: { mac: [rec.mac], ip: Array.from(rec.ips), keywords: ['DHCPREQUEST', 'DHCPACK'], iface: [] } });
                }
            }

            for (const [mac, rapid] of rapidSwitchByMac.entries()) {
                const rec = macIndex.get(mac);
                createFinding({ id: `wifi-switch-${mac}`, title: 'Client roaming/band-switching frequently', severity: rapid.count > 5 ? 'high' : 'medium', category: 'WiFi',
                    affected: [{ mac, ip: rec ? Array.from(rec.ips)[0] || '' : '', hostname: rec ? Array.from(rec.hostnames)[0] || '' : '', iface: Array.from(rapid.interfaces).join('/') }],
                    impact: 'Rapid interface changes suggest aggressive roaming or unstable RF conditions.',
                    evidence: { count: rapid.count, firstSeen: patterns.timeRange.first, lastSeen: patterns.timeRange.last, examples: rapid.samples },
                    suggestedNextChecks: ['Tune roaming thresholds and minimum RSSI.', 'Confirm channel overlap and AP placement.', 'Temporarily disable smart roaming to compare behavior.'],
                    filterKeys: { mac: [mac], ip: rec ? Array.from(rec.ips) : [], keywords: ['AP-STA-CONNECTED', 'AP-STA-DISCONNECTED'], iface: Array.from(rapid.interfaces) } });
            }

            for (const ifaceRec of ifaceIndex.values()) {
                const lowSpeeds = ifaceRec.speeds.filter(speed => DETECTION_THRESHOLDS.ETH_LOW_SPEEDS.includes(speed));
                if (ifaceRec.linkDownCount >= DETECTION_THRESHOLDS.ETH_LINK_FLAP_THRESHOLD) {
                    createFinding({ id: `eth-link-${ifaceRec.interfaceName}`, title: `Ethernet uplink instability on ${ifaceRec.interfaceName}`, severity: ifaceRec.linkDownCount > 3 || lowSpeeds.length > 0 ? 'high' : 'medium', category: 'Ethernet',
                        affected: [{ iface: ifaceRec.interfaceName, note: 'All devices behind this uplink may experience drops.' }],
                        impact: 'Physical link flaps or low negotiated speed may cause short outages and packet loss.',
                        evidence: { count: ifaceRec.linkDownCount + ifaceRec.linkUpCount, firstSeen: patterns.timeRange.first, lastSeen: patterns.timeRange.last, examples: ifaceRec.samples },
                        suggestedNextChecks: ['Inspect cable quality and connectors.', 'Check port errors/duplex mismatch on connected equipment.', 'Validate ISP ONT/modem stability if this is WAN-facing.'],
                        filterKeys: { mac: [], ip: [], keywords: ['Link DOWN', 'Link Up'], iface: [ifaceRec.interfaceName] } });
                }
            }

            if (pppoeSummary.failures >= DETECTION_THRESHOLDS.PPPOE_FAIL_THRESHOLD) {
                createFinding({ id: 'pppoe-instability', title: 'PPPoE session instability detected', severity: 'high', category: 'PPPoE',
                    affected: [{ iface: 'pppoe-wan', note: 'WAN connectivity may drop for all clients.' }],
                    impact: 'PPPoE discovery/session failures can interrupt Internet for every device behind the router.',
                    evidence: { count: pppoeSummary.failures, firstSeen: patterns.timeRange.first, lastSeen: patterns.timeRange.last, examples: pppoeSummary.samples },
                    suggestedNextChecks: ['Check ISP session logs and authentication credentials.', 'Inspect line stability around PPPoE reconnect times.', 'Review router WAN interface error counters.'],
                    filterKeys: { mac: [], ip: [], keywords: ['PADI', 'PADO', 'PADR', 'PADS', 'PADT', 'LCP', 'CHAP', 'PAP', 'pppoe-wan'], iface: ['pppoe-wan'] } });
            }

            for (const rec of macIndex.values()) {
                if (rec.severityEvents.length > 0) {
                    createFinding({ id: `severity-impact-${rec.mac}`, title: 'Device-impacting critical/error event detected', severity: 'medium', category: 'System',
                        affected: [{ mac: rec.mac, ip: Array.from(rec.ips)[0] || '', hostname: Array.from(rec.hostnames)[0] || '' }],
                        impact: 'A high-severity event references this device and may affect service quality.',
                        evidence: { count: rec.severityEvents.length, firstSeen: `${rec.severityEvents[0].date} ${rec.severityEvents[0].time}`, lastSeen: `${rec.severityEvents[rec.severityEvents.length - 1].date} ${rec.severityEvents[rec.severityEvents.length - 1].time}`, examples: rec.severityEvents.slice(0, DETECTION_THRESHOLDS.MAX_FINDING_EXAMPLES).map(e => ({ no: e.no, details: truncate(e.details, 140) })) },
                        suggestedNextChecks: ['Open the filtered events and inspect adjacent log lines for root cause.'],
                        filterKeys: { mac: [rec.mac], ip: Array.from(rec.ips), keywords: ['error', 'critical'], iface: [] } });
                }
            }

            patterns.findings.sort((a, b) => ({ high: 3, medium: 2, low: 1 }[b.severity] - ({ high: 3, medium: 2, low: 1 }[a.severity])) || ((b.evidence?.count || 0) - (a.evidence?.count || 0)));
            patterns.findings = patterns.findings.filter(finding => finding.severity === 'high');
            return patterns;
        }

        function displayEventLogViewer(stats) {
            document.getElementById('pcapViewer').classList.remove('show');
            document.getElementById('eventViewer').classList.add('show');
            document.getElementById('uploadSection').style.display = 'none';

            currentEventStats = stats;
            findingsVisibleCount = 10;
            filteredEvents = allEvents;
            populateEventFilters(stats.categories, stats.severities);
            renderEventTable();
            updateEventPatterns(stats);
            renderFindings(stats.findings || []);
        }

        function renderEventTable() {
            const tbody = document.getElementById('eventTableBody');
            tbody.innerHTML = '';

            const limit = parseInt(document.getElementById('eventDisplayLimit').value);
            const eventsToShow = limit === 0 ? filteredEvents : filteredEvents.slice(0, limit);

            eventsToShow.forEach(event => {
                const row = document.createElement('tr');
                row.onclick = function() {
                    selectedItem = event;
                    document.querySelectorAll('#eventTableBody tr').forEach(tr => tr.classList.remove('selected'));
                    this.classList.add('selected');
                    displayEventDetails(event);
                };

                row.innerHTML = `
                    <td class="text-muted">${event.no}</td>
                    <td class="text-muted">${event.date}<br><small>${event.time}</small></td>
                    <td>${event.category}</td>
                    <td class="protocol-${event.severity.toLowerCase()}">${event.severity}</td>
                    <td class="truncate" title="${event.details}">${truncate(event.details, 80)}</td>
                `;

                tbody.appendChild(row);
            });

            if (filteredEvents.length > eventsToShow.length) {
                const row = document.createElement('tr');
                row.innerHTML = `<td colspan="5" style="text-align: center; color: var(--text-secondary); padding: 15px;">
                    Showing first ${eventsToShow.length.toLocaleString()} of ${filteredEvents.length.toLocaleString()} events
                </td>`;
                tbody.appendChild(row);
            }

            document.getElementById('eventCount').textContent = `${filteredEvents.length.toLocaleString()} events`;
        }

        function displayEventDetails(event) {
            const content = document.getElementById('eventDetailsContent');
            
            let html = `
                <div class="layer-section">
                    <div class="layer-title">Event #${event.no}</div>
                    <div class="detail-row">
                        <span class="detail-label">Date/Time</span>
                        <span class="detail-value">${event.date} ${event.time}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Category</span>
                        <span class="detail-value">${event.category}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Severity</span>
                        <span class="detail-value protocol-${event.severity.toLowerCase()}">${event.severity}</span>
                    </div>
                </div>
                <div class="layer-section">
                    <div class="layer-title">Details</div>
                    <div style="color: var(--text-primary); font-size: 12px; line-height: 1.5;">${event.details}</div>
                </div>
            `;

            content.innerHTML = html;
        }

        function updateEventPatterns(stats) {
            const findings = stats.findings || [];
            const severityCounts = findings.reduce((acc, finding) => {
                acc[finding.severity] = (acc[finding.severity] || 0) + 1;
                return acc;
            }, { high: 0, medium: 0, low: 0 });

            let html = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Total Events</div>
                        <div class="stat-value">${stats.totalEvents.toLocaleString()}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Findings</div>
                        <div class="stat-value">${findings.length}</div>
                        <div class="text-muted" style="font-size: 10px; margin-top: 6px;">H:${severityCounts.high} M:${severityCounts.medium} L:${severityCounts.low}</div>
                    </div>
                </div>
                <div class="protocol-list">
                    <h4 style="color: var(--text-secondary); font-size: 11px; margin: 15px 0 10px;">CATEGORIES</h4>
                    ${Object.entries(stats.categories)
                        .sort((a, b) => b[1] - a[1])
                        .map(([cat, count]) => `
                            <div class="protocol-item">
                                <span>${cat}</span>
                                <span>${count.toLocaleString()}</span>
                            </div>
                        `).join('')}
                </div>
            `;

            if (stats.wifiEvents.deauth.length > 0) {
                html += `
                    <div class="protocol-list">
                        <h4 style="color: var(--text-secondary); font-size: 11px; margin: 15px 0 10px;">WIFI EVENTS</h4>
                        <div class="protocol-item"><span>DEAUTH</span><span>${stats.wifiEvents.deauth.length}</span></div>
                    </div>
                `;
            }

            if (stats.macAddresses.length > 0) {
                html += `
                    <div class="protocol-list">
                        <h4 style="color: var(--text-secondary); font-size: 11px; margin: 15px 0 10px;">MAC ADDRESSES (${stats.macAddresses.length})</h4>
                        <div style="max-height: 150px; overflow-y: auto;">
                            ${stats.macAddresses.slice(0, 10).map(mac => `<div class="protocol-item"><span style="color: var(--cyan);">${mac}</span></div>`).join('')}
                        </div>
                    </div>
                `;
            }

            document.getElementById('eventPatterns').innerHTML = html;
        }

        function findingBadge(severity) {
            return `<span class="finding-badge ${severity}">${severity}</span>`;
        }

        function applyFindingFilter(findingId) {
            if (!currentEventStats || !currentEventStats.findings) return;
            const finding = currentEventStats.findings.find(item => item.id === findingId);
            if (!finding) return;
            activeFindingFilter = finding.filterKeys || {};
            const terms = [];
            ['mac', 'ip', 'iface', 'keywords'].forEach(key => {
                (activeFindingFilter[key] || []).forEach(value => {
                    if (value && !terms.includes(value)) terms.push(value);
                });
            });
            document.getElementById('eventFilter').value = terms.join(' ');
            const categorySelect = document.getElementById('categoryFilter');
            const severitySelect = document.getElementById('severityFilter');
            categorySelect.value = Array.from(categorySelect.options).some(opt => opt.value === finding.category) ? finding.category : '';
            const severityValue = finding.severity ? finding.severity.charAt(0).toUpperCase() + finding.severity.slice(1) : '';
            severitySelect.value = Array.from(severitySelect.options).some(opt => opt.value === severityValue) ? severityValue : ''; 
            applyEventFilters();
            const section = document.getElementById('eventViewer');
            if (section) section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function jumpToFindings() {
            const findingsSection = document.getElementById('findingsSection');
            if (findingsSection) findingsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function showMoreFindings() {
            findingsVisibleCount += 10;
            renderFindings((currentEventStats && currentEventStats.findings) || []);
        }

        function renderFindings(findings) {
            const findingsContent = document.getElementById('findingsContent');
            if (!findingsContent) return;

            if (!findings || findings.length === 0) {
                findingsContent.innerHTML = `
                    <div class="findings-title"><strong>üß≠ Investigation Findings</strong></div>
                    <p class="text-muted">No suspicious patterns detected.</p>
                `;
                return;
            }

            const visibleFindings = findings.slice(0, findingsVisibleCount);
            const html = `
                <div class="findings-title">
                    <strong>üß≠ Investigation Findings (${findings.length})</strong>
                    <span class="text-muted" style="font-size: 11px;">Click ‚ÄúFilter Events‚Äù to focus evidence${activeFindingFilter ? ' ‚Ä¢ filter active' : ''}</span>
                </div>
                <div class="findings-list">
                    ${visibleFindings.map(finding => `
                        <article class="finding-card" id="finding-${finding.id}">
                            <div class="finding-header">
                                <div><strong>${finding.title}</strong> <span class="text-muted">(${finding.category})</span></div>
                                ${findingBadge(finding.severity)}
                            </div>
                            <div class="finding-meta">
                                ${(finding.affected || []).map(item => [item.mac, item.ip, item.hostname, item.iface, item.note].filter(Boolean).join(' ‚Ä¢ ')).join('<br>')}
                            </div>
                            <div class="finding-impact">${finding.impact}</div>
                            <div class="finding-evidence">
                                <strong>Evidence:</strong> ${finding.evidence?.count || 0} events ‚Ä¢ ${finding.evidence?.firstSeen || 'N/A'} ‚Üí ${finding.evidence?.lastSeen || 'N/A'}
                                ${(finding.evidence?.examples || []).map(example => `<div class="finding-example">#${example.no}: ${example.details}</div>`).join('')}
                            </div>
                            <div class="finding-actions">
                                <button class="finding-btn" onclick="applyFindingFilter('${finding.id}')">Filter Events</button>
                                <button class="finding-btn" onclick="clearEventFilters()">Clear Filter</button>
                            </div>
                        </article>
                    `).join('')}
                </div>
                ${findings.length > visibleFindings.length ? `<button class="finding-btn findings-more-btn" onclick="showMoreFindings()">Show more findings</button>` : ''}
            `;
            findingsContent.innerHTML = html;
        }

        function populateEventFilters(categories, severities) {
            const catSelect = document.getElementById('categoryFilter');
            catSelect.innerHTML = '<option value="">All Categories</option>';
            Object.keys(categories).sort().forEach(cat => {
                catSelect.innerHTML += `<option value="${cat}">${cat}</option>`;
            });
            
            const sevSelect = document.getElementById('severityFilter');
            sevSelect.innerHTML = '<option value="">All Severities</option>';
            Object.keys(severities).sort().forEach(sev => {
                sevSelect.innerHTML += `<option value="${sev}">${sev}</option>`;
            });
        }

        function applyEventFilters() {
            const filterText = document.getElementById('eventFilter').value.toLowerCase().trim();
            const categoryFilter = document.getElementById('categoryFilter').value;
            const severityFilter = document.getElementById('severityFilter').value;
            const textTerms = filterText ? filterText.split(/\s+/).filter(Boolean) : [];

            filteredEvents = allEvents.filter(event => {
                if (categoryFilter && event.category !== categoryFilter) return false;
                if (severityFilter && event.severity !== severityFilter) return false;

                const searchIn = `${event.details} ${event.category} ${event.severity} ${event.raw || ''}`.toLowerCase();

                if (activeFindingFilter) {
                    const keys = activeFindingFilter;
                    const terms = [];
                    ['mac', 'ip', 'iface', 'keywords'].forEach(key => {
                        (keys[key] || []).forEach(value => {
                            const normalized = (value || '').toString().trim().toLowerCase();
                            if (normalized && !terms.includes(normalized)) terms.push(normalized);
                        });
                    });
                    if (terms.length > 0 && !terms.some(term => searchIn.includes(term))) return false;
                }

                if (textTerms.length > 0) {
                    if (activeFindingFilter) return textTerms.some(term => searchIn.includes(term));
                    return textTerms.every(term => searchIn.includes(term));
                }

                if (textTerms.length > 0) {
                    if (activeFindingFilter) return textTerms.some(term => searchIn.includes(term));
                    return textTerms.every(term => searchIn.includes(term));
                }

                if (textTerms.length > 0) return textTerms.every(term => searchIn.includes(term));
                return true;
            });

            renderEventTable();
        }

        function clearEventFilters() {
            activeFindingFilter = null;
            document.getElementById('eventFilter').value = '';
            document.getElementById('categoryFilter').value = '';
            document.getElementById('severityFilter').value = '';
            filteredEvents = allEvents;
            renderEventTable();
            renderFindings((currentEventStats && currentEventStats.findings) || []);
        }

        function reset() {
            allPackets = [];
            filteredPackets = [];
            allEvents = [];
            filteredEvents = [];
            selectedItem = null;
            mode = null;
            ipEndpoints.clear();
            macEndpoints.clear();
            rogueDevices = [];
            pcapFindings = [];
            pcapFindingsSummary = { total: 0, high: 0, medium: 0, low: 0 };
            
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('pcapViewer').classList.remove('show');
            document.getElementById('eventViewer').classList.remove('show');
            document.getElementById('pcapBtn').classList.remove('active');
            document.getElementById('eventlogBtn').classList.remove('active');
            document.getElementById('fileInput').value = '';
            document.getElementById('packetFilter').value = '';
            document.getElementById('eventFilter').value = '';
            activeFindingFilter = null;
            if (document.getElementById('findingsContent')) {
                document.getElementById('findingsContent').innerHTML = '';
            }
        }

        // Debug function to test security detection
        function testSecurityDetection() {
            console.log("=== Security Detection Test ===");
            console.log(`Total packets: ${allPackets.length}`);
            console.log(`ARP packets: ${allPackets.filter(p => p.protocol === 'ARP').length}`);
            console.log(`DHCP packets: ${allPackets.filter(p => p.protocol === 'DHCP').length}`);
            console.log(`DNS packets: ${allPackets.filter(p => p.protocol === 'DNS').length}`);
            console.log(`Rogue devices detected: ${rogueDevices.length}`);
            console.log("Rogue devices:", rogueDevices);
            
            // Force re-render of security tab
            renderRogueDevices();
            
            // Switch to security tab to show results
            switchSidebarTab('security');
            
            return rogueDevices;
        }
    </script>
</body>
</html>
